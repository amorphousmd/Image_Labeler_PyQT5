# -*- coding: utf-8 -*-

#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


import os
import numpy as np
import re
import json
import random
import ast
import cv2
import copy
import math
import glob
import yaml
import shutil
import subprocess
import threading
from PIL import Image
from sklearn.model_selection import train_test_split

from PyQt5 import QtCore, QtGui, QtWidgets, uic
from PyQt5.QtGui import QPixmap, QPainter
from PyQt5.QtCore import Qt, QRectF, QTimer
from PyQt5.QtWidgets import QGraphicsScene, QFileDialog, QVBoxLayout
from PyQt5.QtChart import QLineSeries, QValueAxis, QChart, QChartView

# YOLOv5 bounding boxes colors
_COLORS = np.array(
    [
        0.000, 0.447, 0.741,
        0.850, 0.325, 0.098,
        0.929, 0.694, 0.125,
        0.494, 0.184, 0.556,
        0.466, 0.674, 0.188,
        0.301, 0.745, 0.933,
        0.635, 0.078, 0.184,
        0.300, 0.300, 0.300,
        0.600, 0.600, 0.600,
        1.000, 0.000, 0.000,
        1.000, 0.500, 0.000,
        0.749, 0.749, 0.000,
        0.000, 1.000, 0.000,
        0.000, 0.000, 1.000,
        0.667, 0.000, 1.000,
        0.333, 0.333, 0.000,
        0.333, 0.667, 0.000,
        0.333, 1.000, 0.000,
        0.667, 0.333, 0.000,
        0.667, 0.667, 0.000,
        0.667, 1.000, 0.000,
        1.000, 0.333, 0.000,
        1.000, 0.667, 0.000,
        1.000, 1.000, 0.000,
        0.000, 0.333, 0.500,
        0.000, 0.667, 0.500,
        0.000, 1.000, 0.500,
        0.333, 0.000, 0.500,
        0.333, 0.333, 0.500,
        0.333, 0.667, 0.500,
        0.333, 1.000, 0.500,
        0.667, 0.000, 0.500,
        0.667, 0.333, 0.500,
        0.667, 0.667, 0.500,
        0.667, 1.000, 0.500,
        1.000, 0.000, 0.500,
        1.000, 0.333, 0.500,
        1.000, 0.667, 0.500,
        1.000, 1.000, 0.500,
        0.000, 0.333, 1.000,
        0.000, 0.667, 1.000,
        0.000, 1.000, 1.000,
        0.333, 0.000, 1.000,
        0.333, 0.333, 1.000,
        0.333, 0.667, 1.000,
        0.333, 1.000, 1.000,
        0.667, 0.000, 1.000,
        0.667, 0.333, 1.000,
        0.667, 0.667, 1.000,
        0.667, 1.000, 1.000,
        1.000, 0.000, 1.000,
        1.000, 0.333, 1.000,
        1.000, 0.667, 1.000,
        0.333, 0.000, 0.000,
        0.500, 0.000, 0.000,
        0.667, 0.000, 0.000,
        0.833, 0.000, 0.000,
        1.000, 0.000, 0.000,
        0.000, 0.167, 0.000,
        0.000, 0.333, 0.000,
        0.000, 0.500, 0.000,
        0.000, 0.667, 0.000,
        0.000, 0.833, 0.000,
        0.000, 1.000, 0.000,
        0.000, 0.000, 0.167,
        0.000, 0.000, 0.333,
        0.000, 0.000, 0.500,
        0.000, 0.000, 0.667,
        0.000, 0.000, 0.833,
        0.000, 0.000, 1.000,
        0.000, 0.000, 0.000,
        0.143, 0.143, 0.143,
        0.286, 0.286, 0.286,
        0.429, 0.429, 0.429,
        0.571, 0.571, 0.571,
        0.714, 0.714, 0.714,
        0.857, 0.857, 0.857,
        0.000, 0.447, 0.741,
        0.314, 0.717, 0.741,
        0.50, 0.5, 0
    ]
).astype(np.float32).reshape(-1, 3)


class Ui_Dialog(QtWidgets.QDialog):
    def __init__(self):
        super().__init__()
        uic.loadUi('GUIDesign.ui', self)
        self.scene = QGraphicsScene()
        self.graphicsView.setScene(self.scene)
        self.graphicsView.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.graphicsView.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.graphicsView.setRenderHint(QtGui.QPainter.Antialiasing)
        self.graphicsView.setRenderHint(QtGui.QPainter.SmoothPixmapTransform)
        self.graphicsView.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)
        self.comboBox.setEditable(True)
        self.comboBox.lineEdit().setAlignment(QtCore.Qt.AlignCenter)
        self.comboBox.addItems('Class 0, Class 1, Class 2'.split(","))
        line_edit = self.comboBox.lineEdit()
        line_edit.setAlignment(Qt.AlignCenter)
        line_edit.setReadOnly(True)
        font = QtGui.QFont()
        font.setPointSize(8)  # set the font size to 12 points
        self.bbox_tbrowser.setFont(font)
        self.output_format_combobox.addItem("YOLOv7 Pytorch (.txt)")
        self.output_format_combobox.addItem("YOLOv5 Pytorch (.txt)")
        self.output_format_combobox.addItem("COCO (.json)")
        self.output_format_combobox.addItem("KeyPoints RCNN (.json)")
        self.output_format_combobox.addItem("Tensorflow Detection (.csv)")
        self.model_combobox.addItem("YOLOv7")
        self.model_combobox.addItem("YOLOv7-tiny")
        self.epochs_combobox.addItem("25")
        self.epochs_combobox.addItem("50")
        self.epochs_combobox.addItem("100")
        self.epochs_combobox.addItem("200")
        self.batchsize_combobox.addItem("1")
        self.batchsize_combobox.addItem("2")
        self.batchsize_combobox.addItem("4")
        self.batchsize_combobox.addItem("8")
        self.batchsize_combobox.addItem("16")
        self.batchsize_combobox.addItem("32")
        self.learnrate_combobox.addItem("0.01")
        self.learnrate_combobox.addItem("0.05")
        self.learnrate_combobox.addItem("0.1")
        self.learnrate_combobox.addItem("0.001")
        self.training_thread = None

        # Timer
        self.log_file_timer = QTimer()
        self.log_file_timer.timeout.connect(self.read_log_file)
        self.log_file_timer.start(1000)  # Check the log file every second
        self.last_epoch_processed = -1

        # QChart visualization setup
        # Initialize the main chart
        # Initialize the line series for loss, precision, recall, and map
        self.loss_series = QLineSeries()
        self.precision_series = QLineSeries()
        self.recall_series = QLineSeries()
        self.map_series = QLineSeries()
        # Create chart 1 for loss series
        self.chart1 = QChart()
        self.chart1.setTitle("Loss Progress")
        self.chart1.legend().hide()
        self.chartview1 = QChartView(self.chart1, self.tab_2)
        self.chartview1.setGeometry(QtCore.QRect(340, 120, 430, 335))
        self.chartview1.setRenderHint(QPainter.Antialiasing)
        self.chart1.addSeries(self.loss_series)
        self.axisX1 = QValueAxis()
        self.axisX1.setLabelFormat("%d")
        self.axisX1.setTitleText("Epoch")
        self.axisX1.setTickCount(11)
        self.axisX1.setRange(0, 50)
        self.chart1.addAxis(self.axisX1, Qt.AlignBottom)
        self.axisY1 = QValueAxis()
        self.axisY1.setLabelFormat("%.2f")
        self.axisY1.setTitleText("Loss")
        self.axisY1.setTickCount(6)
        self.chart1.addAxis(self.axisY1, Qt.AlignLeft)
        self.loss_series.attachAxis(self.axisX1)
        self.loss_series.attachAxis(self.axisY1)

        # Create chart 2 for precision series
        self.chart2 = QChart()
        self.chart2.setTitle("Precision Progress")
        self.chart2.legend().hide()
        self.chartview2 = QChartView(self.chart2, self.tab_2)
        self.chartview2.setGeometry(QtCore.QRect(770, 120, 431, 335))
        self.chartview2.setRenderHint(QPainter.Antialiasing)
        self.chart2.addSeries(self.precision_series)
        self.axisX2 = QValueAxis()
        self.axisX2.setLabelFormat("%d")
        self.axisX2.setTitleText("Epoch")
        self.axisX2.setTickCount(11)
        self.axisX2.setRange(0, 50)
        self.chart2.addAxis(self.axisX2, Qt.AlignBottom)
        self.axisY2 = QValueAxis()
        self.axisY2.setLabelFormat("%.2f")
        self.axisY2.setTitleText("Precision")
        self.axisY2.setTickCount(6)
        self.chart2.addAxis(self.axisY2, Qt.AlignLeft)
        self.precision_series.attachAxis(self.axisX2)
        self.precision_series.attachAxis(self.axisY2)

        # Create chart 3 for recall series
        self.chart3 = QChart()
        self.chart3.setTitle("Recall Progress")
        self.chart3.legend().hide()
        self.chartview3 = QChartView(self.chart3, self.tab_2)
        self.chartview3.setGeometry(QtCore.QRect(340, 480, 430, 311))
        self.chartview3.setRenderHint(QPainter.Antialiasing)
        self.chart3.addSeries(self.recall_series)
        self.axisX3 = QValueAxis()
        self.axisX3.setLabelFormat("%d")
        self.axisX3.setTitleText("Epoch")
        self.axisX3.setTickCount(11)
        self.axisX3.setRange(0, 50)
        self.chart3.addAxis(self.axisX3, Qt.AlignBottom)
        self.axisY3 = QValueAxis()
        self.axisY3.setLabelFormat("%.2f")
        self.axisY3.setTitleText("Recall")
        self.axisY3.setTickCount(6)
        self.chart3.addAxis(self.axisY3, Qt.AlignLeft)
        self.recall_series.attachAxis(self.axisX3)
        self.recall_series.attachAxis(self.axisY3)

        # Create chart 4 for map series
        self.chart4 = QChart()
        self.chart4.setTitle("mAP Progress")
        self.chart4.legend().hide()
        self.chartview4 = QChartView(self.chart4, self.tab_2)
        self.chartview4.setGeometry(QtCore.QRect(770, 480, 431, 311))
        self.chartview4.setRenderHint(QPainter.Antialiasing)
        self.chart4.addSeries(self.map_series)
        self.axisX4 = QValueAxis()
        self.axisX4.setLabelFormat("%d")
        self.axisX4.setTitleText("Epoch")
        self.axisX4.setTickCount(11)
        self.axisX4.setRange(0, 50)
        self.chart4.addAxis(self.axisX4, Qt.AlignBottom)
        self.axisY4 = QValueAxis()
        self.axisY4.setLabelFormat("%.2f")
        self.axisY4.setTitleText("mAP")
        self.axisY4.setTickCount(6)
        self.axisY4.setRange(0, 0.001)
        self.chart4.addAxis(self.axisY4, Qt.AlignLeft)
        self.map_series.attachAxis(self.axisX4)
        self.map_series.attachAxis(self.axisY4)

        # Set up general variables that are used for keeping track of annotated images
        self.image_loaded = False
        self.annotated_bboxes = {}
        self.annotated_keypoints = {}
        self.annotated_bboxes_noaug = {}
        self.dataset_metadata = {}
        self.filename = None
        self.current_file = None
        self.current_dir = "./"
        self.current_class_id = '0'
        self.selected_type = None
        self.selected_bbox = None
        self.selected_kpt = None
        self.scale_factor = 1.0
        self.tvt_split_ratio = 0.8
        self.vt_split_ratio = 0.5

        # Connections
        self.cd_button.clicked.connect(self.load_image)
        self.comboBox.currentIndexChanged.connect(self.select_class)
        self.bbox_tbrowser.itemClicked.connect(self.item_clicked)
        self.bbox_tbrowser.focusOutEvent = self.bbox_tbrowser_focus_out
        self.finish_button.clicked.connect(self.save_annotations)
        self.load_annotate_button.clicked.connect(self.load_annotations)
        self.prev_button.clicked.connect(self.load_prev)
        self.next_button.clicked.connect(self.load_next)
        self.goto_button.clicked.connect(self.goto_index)
        self.dir_change_button.clicked.connect(self.change_directory)
        self.augment_button.clicked.connect(self.augment)
        self.tvt_slider.valueChanged.connect(lambda value: self.tvt_label.setText(str(value)))
        self.vt_slider.valueChanged.connect(lambda value: self.vt_label.setText(str(value)))
        self.generate_dataset_button.clicked.connect(self.generate_dataset)
        self.train_button.clicked.connect(self.train)

        QtCore.QMetaObject.connectSlotsByName(Dialog)
        self.graphicsView.viewport().installEventFilter(self)
        self.graphicsView.setMouseTracking(True)  # add this line
        self.graphicsView.viewport().setCursor(QtCore.Qt.ArrowCursor)
        shortcut = QtWidgets.QShortcut(QtGui.QKeySequence(QtCore.Qt.Key_Escape), self)
        shortcut.activated.connect(self.handleEscape)

        # Setup the values for action handling
        self.startPos = None
        self.endPos = None
        self.drawnBox = False
        self.isDrawing = False
        self.drawnArrow = False
        self.isDrawingArrow = False
        self.dottedLines = []  # initialize a list to keep track of the dotted lines
        self.ctrl_pressed = False
        self.last_mouse_pos = None
        self.graphicsView.viewport().installEventFilter(self)
        self.graphicsView.setMouseTracking(True)
        self.graphicsView.viewport().setCursor(QtCore.Qt.ArrowCursor)
        shortcut = QtWidgets.QShortcut(QtGui.QKeySequence(QtCore.Qt.Key_Escape), self)
        shortcut.activated.connect(self.handleEscape)

    def load_image(self):
        print(self.annotated_bboxes)
        print(self.dataset_metadata)
        print(self.annotated_keypoints)
        for line in self.dottedLines:
            self.graphicsView.scene().removeItem(line)
        self.dottedLines = []
        # Get the path to the image file using a file dialog
        self.filename, _ = QFileDialog.getOpenFileName(directory="C:/Users/LAPTOP/Desktop/Pics",
                                                       filter="Images (*.png *.xpm *.jpg *.bmp);;All Files (*)")
        if not self.filename:
            return
        self.current_file = str(os.path.basename(self.filename))
        self.current_dir = str(os.path.dirname(self.filename))
        if self.current_file not in self.annotated_bboxes:
            self.annotated_bboxes[self.current_file] = {}
        if self.current_file not in self.dataset_metadata:
            self.dataset_metadata[self.current_file] = {}
        if self.current_file not in self.annotated_keypoints:
            self.annotated_keypoints[self.current_file] = {}

        self.image_label.setText(self.current_file)
        self.directory_tbrowser.setText(self.current_dir)
        # Load the image file as a pixmap
        self.graphicsView.scene().clear()
        pixmap = QPixmap(self.filename)
        if pixmap.isNull():
            return
        self.dataset_metadata[self.current_file]['_size'] = [pixmap.width(), pixmap.height()]
        # Set the pixmap as the background for the QGraphicsView widget
        self.scene.clear()
        self.scene.addPixmap(pixmap)
        self.graphicsView.setSceneRect(QRectF(pixmap.rect()))
        self.graphicsView.fitInView(QRectF(pixmap.rect()), Qt.KeepAspectRatio)
        self.redrawBoundingBox(self.current_file)
        self.rewrite_bbox_list(self.current_file)
        self.redrawKeypoints(self.current_file)
        self.image_loaded = True

    def load_image_nopath(self, name):
        for line in self.dottedLines:
            self.graphicsView.scene().removeItem(line)
        self.dottedLines = []
        # Get the path to the image file using a file dialog
        self.filename = self.current_dir + '/' + name
        if not self.filename:
            return
        self.current_file = str(os.path.basename(self.filename))
        self.current_dir = str(os.path.dirname(self.filename))
        if self.current_file not in self.annotated_bboxes:
            self.annotated_bboxes[self.current_file] = {}
        if self.current_file not in self.dataset_metadata:
            self.dataset_metadata[self.current_file] = {}
        if self.current_file not in self.annotated_keypoints:
            self.annotated_keypoints[self.current_file] = {}

        self.image_label.setText(self.current_file)
        self.directory_tbrowser.setText(self.current_dir)
        # Load the image file as a pixmap
        self.graphicsView.scene().clear()
        pixmap = QPixmap(self.filename)
        if pixmap.isNull():
            return
        self.dataset_metadata[self.current_file]['_size'] = [pixmap.width(), pixmap.height()]
        # Set the pixmap as the background for the QGraphicsView widget
        self.scene.clear()
        self.scene.addPixmap(pixmap)
        self.graphicsView.setSceneRect(QRectF(pixmap.rect()))
        self.graphicsView.fitInView(QRectF(pixmap.rect()), Qt.KeepAspectRatio)
        self.redrawBoundingBox(self.current_file)
        self.rewrite_bbox_list(self.current_file)
        self.redrawKeypoints(self.current_file)
        self.image_loaded = True

    def touch_image(self, name):
        self.filename = './Dataset/' + name
        if not self.filename:
            return

        pixmap = QPixmap(self.filename)
        if pixmap.isNull():
            return
        if name not in self.dataset_metadata:
            self.dataset_metadata[name] = {}
        self.dataset_metadata[name]['_size'] = [pixmap.width(), pixmap.height()]

    def change_directory(self):
        options = QFileDialog.Options()
        options |= QFileDialog.DontUseNativeDialog
        current_dir = os.getcwd()
        folder_path = QFileDialog.getExistingDirectory(self, "Select Folder", current_dir, options=options)
        self.current_dir = folder_path
        files = sorted([f for f in os.listdir(self.current_dir) if f.endswith('.jpg') or f.endswith('.png')])
        self.load_image_nopath(files[0])

    def load_next(self):
        parent_dir = self.current_dir
        file = self.current_file
        if file is None or parent_dir is None:
            return
        files = sorted([f for f in os.listdir(parent_dir) if f.endswith('.jpg') or f.endswith('.png')])
        current_index = files.index(file)
        if current_index == len(files) - 1:
            return None  # reached end of list
        else:
            self.load_image_nopath(files[current_index + 1])
            return files[current_index + 1]

    def load_prev(self):
        parent_dir = self.current_dir
        file = self.current_file
        if file is None or parent_dir is None:
            return
        files = sorted([f for f in os.listdir(parent_dir) if f.endswith('.jpg') or f.endswith('.png')])
        current_index = files.index(file)
        if current_index == 0:
            return None  # reached beginning of list
        else:
            self.load_image_nopath(files[current_index - 1])
            return files[current_index - 1]

    def goto_index(self):
        parent_dir = self.current_dir
        file = self.current_file
        if file is None or parent_dir is None:
            return
        files = sorted([f for f in os.listdir(parent_dir) if f.endswith('.jpg') or f.endswith('.png')])
        index_str = self.index_ledit.text()  # Get the text from the line edit
        try:
            index = int(index_str)  # Convert the text to an integer
        except ValueError:
            return  # If the text cannot be converted to an integer, do nothing
        if index < 0:
            index = 0  # If the index is negative, set it to 0
        elif index > len(files) - 1:
            index = len(files) - 1  # If the index is greater than the maximum index, set it to the maximum index
        self.load_image_nopath(files[index])


    def select_class(self, i):
        self.current_class_id = str(i)
        print("Current class:", i)

    def redrawBoundingBox(self, current_file):
        # iterate over each image file in the dictionary
        try:
            for key, value in self.annotated_bboxes[current_file].items():
                for bbox in value:
                    x, y, w, h = bbox
                    rect = QtCore.QRectF(x, y, w, h)
                    item = QtWidgets.QGraphicsRectItem(rect)
                    R, G, B = [int(i * 255) for i in _COLORS[int(key)]]
                    item.setPen(QtGui.QPen(QtGui.QColor(R, G, B)))
                    item.setBrush(QtGui.QBrush(QtGui.QColor(R, G, B, 50)))
                    self.scene.addItem(item)
        except KeyError:
            return

    def redrawBoundingBoxExcept(self, current_file, except_bbox, highlight_class):
        for item in self.scene.items():
            if isinstance(item, QtWidgets.QGraphicsRectItem):
                self.scene.removeItem(item)

        # iterate over each image file in the dictionary
        for key, value in self.annotated_bboxes[current_file].items():
            for bbox in value:
                if bbox == except_bbox:
                    continue
                x, y, w, h = bbox
                rect = QtCore.QRectF(x, y, w, h)
                item = QtWidgets.QGraphicsRectItem(rect)
                R, G, B = [int(i * 255) for i in _COLORS[int(key)]]
                item.setPen(QtGui.QPen(QtGui.QColor(R, G, B)))
                item.setBrush(QtGui.QBrush(QtGui.QColor(R, G, B, 50)))
                self.scene.addItem(item)
        x, y, w, h = except_bbox
        rect = QtCore.QRectF(x, y, w, h)
        item = QtWidgets.QGraphicsRectItem(rect)
        R, G, B = [int(i * 255) for i in _COLORS[int(highlight_class)]]
        item.setPen(QtGui.QPen(QtGui.QColor(R, G, B)))
        item.setBrush(QtGui.QBrush(QtGui.QColor(R, G, B, 150)))
        self.scene.addItem(item)

    def redrawKeypoints(self, current_file):
        # iterate over each image file in the dictionary
        try:
            for key, value in self.annotated_keypoints[current_file].items():
                for keypoints in value:
                    arrowStart = QtCore.QPointF(*keypoints[0][:2])
                    arrowEnd = QtCore.QPointF(*keypoints[1][:2])
                    arrow = QtGui.QPainterPath()
                    arrow.moveTo(arrowStart)
                    arrow.lineTo(arrowEnd)
                    arrow_head_len = 20
                    arrow_head_angle = 45
                    angle = math.atan2(arrowEnd.y() - arrowStart.y(), arrowEnd.x() - arrowStart.x())
                    arrow_p1 = QtCore.QPointF(
                        arrowEnd.x() + arrow_head_len * math.cos(angle - math.pi + math.radians(arrow_head_angle)),
                        arrowEnd.y() + arrow_head_len * math.sin(angle - math.pi + math.radians(arrow_head_angle)))
                    arrow_p2 = QtCore.QPointF(
                        arrowEnd.x() + arrow_head_len * math.cos(angle - math.pi - math.radians(arrow_head_angle)),
                        arrowEnd.y() + arrow_head_len * math.sin(angle - math.pi - math.radians(arrow_head_angle)))
                    arrow.lineTo(arrow_p1)
                    arrow.moveTo(arrowEnd)
                    arrow.lineTo(arrow_p2)
                    item = QtWidgets.QGraphicsPathItem(arrow)
                    # Grabbing the colors from indices
                    R, G, B = [int(i * 255) for i in _COLORS[int(self.current_class_id)]]
                    item.setPen(QtGui.QPen(QtGui.QColor(R, G, B), 3))
                    self.scene.addItem(item)
        except KeyError:
            return

    def redrawKeypointsExcept(self, current_file, except_kpt, highlight_class):
        for item in self.scene.items():
            if isinstance(item, QtWidgets.QGraphicsPathItem):
                self.scene.removeItem(item)
        # iterate over each image file in the dictionary
        for key, value in self.annotated_keypoints[current_file].items():
            for keypoints in value:
                if keypoints == except_kpt:
                    continue
                arrowStart = QtCore.QPointF(*keypoints[0][:2])
                arrowEnd = QtCore.QPointF(*keypoints[1][:2])
                arrow = QtGui.QPainterPath()
                arrow.moveTo(arrowStart)
                arrow.lineTo(arrowEnd)
                arrow_head_len = 20
                arrow_head_angle = 45
                angle = math.atan2(arrowEnd.y() - arrowStart.y(), arrowEnd.x() - arrowStart.x())
                arrow_p1 = QtCore.QPointF(
                    arrowEnd.x() + arrow_head_len * math.cos(angle - math.pi + math.radians(arrow_head_angle)),
                    arrowEnd.y() + arrow_head_len * math.sin(angle - math.pi + math.radians(arrow_head_angle)))
                arrow_p2 = QtCore.QPointF(
                    arrowEnd.x() + arrow_head_len * math.cos(angle - math.pi - math.radians(arrow_head_angle)),
                    arrowEnd.y() + arrow_head_len * math.sin(angle - math.pi - math.radians(arrow_head_angle)))
                arrow.lineTo(arrow_p1)
                arrow.moveTo(arrowEnd)
                arrow.lineTo(arrow_p2)
                item = QtWidgets.QGraphicsPathItem(arrow)
                # Grabbing the colors from indices
                R, G, B = [int(i * 255) for i in _COLORS[int(self.current_class_id)]]
                item.setPen(QtGui.QPen(QtGui.QColor(R, G, B), 3))
                self.scene.addItem(item)
        arrowStart = QtCore.QPointF(*except_kpt[0][:2])
        arrowEnd = QtCore.QPointF(*except_kpt[1][:2])
        arrow = QtGui.QPainterPath()
        arrow.moveTo(arrowStart)
        arrow.lineTo(arrowEnd)
        arrow_head_len = 20
        arrow_head_angle = 45
        angle = math.atan2(arrowEnd.y() - arrowStart.y(), arrowEnd.x() - arrowStart.x())
        arrow_p1 = QtCore.QPointF(
            arrowEnd.x() + arrow_head_len * math.cos(angle - math.pi + math.radians(arrow_head_angle)),
            arrowEnd.y() + arrow_head_len * math.sin(angle - math.pi + math.radians(arrow_head_angle)))
        arrow_p2 = QtCore.QPointF(
            arrowEnd.x() + arrow_head_len * math.cos(angle - math.pi - math.radians(arrow_head_angle)),
            arrowEnd.y() + arrow_head_len * math.sin(angle - math.pi - math.radians(arrow_head_angle)))
        arrow.lineTo(arrow_p1)
        arrow.moveTo(arrowEnd)
        arrow.lineTo(arrow_p2)
        item = QtWidgets.QGraphicsPathItem(arrow)
        # Grabbing the colors from indices
        R, G, B = [int(i * 255) for i in _COLORS[int(highlight_class)]]
        item.setPen(QtGui.QPen(QtGui.QColor(R, G, 0), 3))
        self.scene.addItem(item)

    def item_clicked(self, item):
        s = item.text()
        type = s.split(': ')[0]
        if type == 'bbox':
            s = s.split(': ')[1]
            tuple_str = re.search(r'\(([\d\.]+),\s*([\d\.]+),\s*([\d\.]+),\s*([\d\.]+)\)', s).group(1, 2, 3, 4)
            bbox = tuple(map(float, tuple_str))
            self.selected_type = 0
            self.selected_bbox = bbox
            highlight_class = s.split(' ')[0]
            self.redrawBoundingBoxExcept(self.current_file, bbox, highlight_class)
        if type == 'kpt':
            s = s.split(': ')[1]
            match = re.search(r"\[\[.*\]\]", s)
            if match:
                result = match.group()
            highlight_class = s.split(' ')[0]
            kpt = ast.literal_eval(result)
            self.selected_kpt = kpt
            self.selected_type = 1
            self.redrawKeypointsExcept(self.current_file, kpt, highlight_class)

    def bbox_tbrowser_focus_out(self, event):
        for item in self.scene.items():
            if isinstance(item, QtWidgets.QGraphicsRectItem):
                self.scene.removeItem(item)
        self.redrawBoundingBox(self.current_file)

    def rewrite_bbox_list(self, current_file):
        self.bbox_tbrowser.clear()
        for key, value in self.annotated_bboxes[current_file].items():
            for bbox in value:
                self.bbox_tbrowser.addItem(key + ' ' + str(bbox))
        for key, value in self.annotated_keypoints[current_file].items():
            for keypoints in value:
                self.bbox_tbrowser.addItem(key + ' ' + str(keypoints))

    def save_annotations(self):
        filename, _ = QtWidgets.QFileDialog.getSaveFileName(self, "Save File", "./Saves", "JSON Files (*.json)")

        if filename:
            # create dictionary to save
            data = {
                'annotated_bboxes': self.annotated_bboxes,
                'dataset_metadata': self.dataset_metadata,
                'annotated_keypoints': self.annotated_keypoints
            }
            # write dictionary to file as JSON
            with open(filename, 'w') as f:
                json.dump(data, f)

    def load_annotations(self):
        file_path, _ = QFileDialog.getOpenFileName(None, "Open JSON file", "./Saves", "JSON Files (*.json)")

        if file_path:
            with open(file_path, 'r') as f:
                data = json.load(f)
        try:
            for img, classes in data["annotated_bboxes"].items():
                for cls, bboxes in classes.items():
                    data["annotated_bboxes"][img][cls] = [tuple(bbox) for bbox in bboxes]
        except UnboundLocalError:
            print('No file selected')
            return

        self.annotated_bboxes = data["annotated_bboxes"]
        self.dataset_metadata = data["dataset_metadata"]
        self.annotated_keypoints = data["annotated_keypoints"]

        try:
            self.redrawBoundingBox(self.current_file)
        except KeyError:
            pass
        try:
            self.rewrite_bbox_list(self.current_file)
        except KeyError:
            pass

    def handleEscape(self):
        pass  # Without doing this the GUI just closes whenever you press ESC

    def keyPressEvent(self, event):
        if event.key() == QtCore.Qt.Key_B:
            self.isDrawing = True
            event.accept()  # accept the event to stop it from propagating to other widgets
        elif event.key() == QtCore.Qt.Key_A:
            self.isDrawingArrow = True
            event.accept()  # accept the event to stop it from propagating to other widgets
        elif event.key() == QtCore.Qt.Key_Delete:
            if self.selected_type == 0:
                for key, value in self.annotated_bboxes[self.current_file].items():
                    for bbox in value:
                        if bbox == self.selected_bbox:
                            self.annotated_bboxes[self.current_file][key].remove(bbox)
                            bbox_to_remove = 'bbox: ' + key + ' ' + str(bbox)
                            for i in range(self.bbox_tbrowser.count()):
                                if self.bbox_tbrowser.item(i).text() == bbox_to_remove:
                                    self.bbox_tbrowser.takeItem(i)
                                    break
                for item in self.scene.items():
                    if isinstance(item, QtWidgets.QGraphicsRectItem):
                        self.scene.removeItem(item)
                self.redrawBoundingBox(self.current_file)
                event.accept()  # accept the event to stop it from propagating to other widgets

            elif self.selected_type == 1:
                print('here')
                for key, value in self.annotated_keypoints[self.current_file].items():
                    for keypoints in value:
                        print(keypoints)
                        print(self.selected_kpt)
                        if keypoints == self.selected_kpt:
                            print('here')
                            self.annotated_keypoints[self.current_file][key].remove(keypoints)
                            kpt_to_remove = 'kpt: ' + key + ' ' + str(keypoints)
                            for i in range(self.bbox_tbrowser.count()):
                                if self.bbox_tbrowser.item(i).text() == kpt_to_remove:
                                    self.bbox_tbrowser.takeItem(i)
                                    break
                for item in self.scene.items():
                    if isinstance(item, QtWidgets.QGraphicsPathItem):
                        self.scene.removeItem(item)
                self.redrawKeypoints(self.current_file)
                event.accept()  # accept the event to stop it from propagating to other widgets

        elif event.type() == QtCore.QEvent.KeyPress and event.key() == QtCore.Qt.Key_Control:
            self.ctrl_pressed = True
            self.graphicsView.viewport().setCursor(QtCore.Qt.OpenHandCursor)
        else:
            super().keyPressEvent(event)

    def keyReleaseEvent(self, event):
        if event.key() == QtCore.Qt.Key_Control:
            self.ctrl_pressed = False
            self.graphicsView.viewport().setCursor(QtCore.Qt.ArrowCursor)
            event.accept()  # accept the event to stop it from propagating to other widgets

    def eventFilter(self, source, event):
        if event.type() == QtCore.QEvent.MouseMove:
            if not self.image_loaded:
                return super(Ui_Dialog, self).eventFilter(source, event)
            # get the position of the mouse cursor in the scene coordinates
            scenePos = self.graphicsView.mapToScene(event.pos())

            # get the rectangle of the visible area in the view coordinates
            viewRect = self.graphicsView.viewport().rect()

            # clear any existing dotted lines
            try:
                for line in self.dottedLines:
                    self.graphicsView.scene().removeItem(line)
                self.dottedLines = []
            except RuntimeError:
                return super(Ui_Dialog, self).eventFilter(source, event)

            # create a QPen object for the dotted line
            dottedLinePen = QtGui.QPen(QtCore.Qt.DotLine)
            dottedLinePen.setWidth(1)

            # add horizontal and vertical dotted lines intersecting at the cursor position
            horizLine = QtWidgets.QGraphicsLineItem(viewRect.left(), scenePos.y(), viewRect.right(), scenePos.y())
            horizLine.setPen(dottedLinePen)
            self.graphicsView.scene().addItem(horizLine)
            self.dottedLines.append(horizLine)

            vertLine = QtWidgets.QGraphicsLineItem(scenePos.x(), viewRect.top(), scenePos.x(), viewRect.bottom())
            vertLine.setPen(dottedLinePen)
            self.graphicsView.scene().addItem(vertLine)
            self.dottedLines.append(vertLine)

            if self.drawnBox:
                pos = self.graphicsView.mapToScene(event.pos())
                self.endPos = pos
                self.drawBoundingBoxPreview()

            if self.drawnArrow:
                pos = self.graphicsView.mapToScene(event.pos())
                self.arrowEnd = pos
                self.drawArrowPreview()

            if event.buttons() == QtCore.Qt.LeftButton and self.ctrl_pressed:
                cursor = QtGui.QCursor()
                if self.last_mouse_pos is None:
                    self.last_mouse_pos = cursor.pos()
                    return True
                delta = cursor.pos() - self.last_mouse_pos
                self.last_mouse_pos = cursor.pos()
                dx = delta.x()
                dy = delta.y()
                self.graphicsView.horizontalScrollBar().setValue(self.graphicsView.horizontalScrollBar().value() - dx)
                self.graphicsView.verticalScrollBar().setValue(self.graphicsView.verticalScrollBar().value() - dy)
                return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease and event.button() == QtCore.Qt.LeftButton and \
                event.modifiers() == QtCore.Qt.ControlModifier:
            self.last_mouse_pos = None
            return True

        elif event.type() == QtCore.QEvent.MouseButtonPress and event.button() == QtCore.Qt.LeftButton:
            if self.isDrawing:
                if not self.drawnBox:
                    # start drawing
                    pos = self.graphicsView.mapToScene(event.pos())
                    print(pos)
                    self.startPos = pos
                    self.endPos = pos
                    self.drawnBox = True
                    return True
                else:
                    # finish drawing
                    pos = self.graphicsView.mapToScene(event.pos())
                    print(pos)
                    self.endPos = pos
                    self.drawnBox = False
                    self.isDrawing = False
                    # Get the x and y coordinates of the upper left corner of the bounding box
                    x = min(self.startPos.x(), self.endPos.x())
                    y = min(self.startPos.y(), self.endPos.y())

                    # Get the width and height of the bounding box
                    w = abs(self.startPos.x() - self.endPos.x())
                    h = abs(self.startPos.y() - self.endPos.y())

                    # Create the tuple with (x, y, w, h) coordinates
                    bbox = (round(x, 2), round(y, 2), round(w, 2), round(h, 2))
                    self.drawBoundingBox()
                    if self.current_class_id not in self.annotated_bboxes[self.current_file]:
                        self.annotated_bboxes[self.current_file][self.current_class_id] = []
                    self.annotated_bboxes[self.current_file][self.current_class_id].append(bbox)
                    self.bbox_tbrowser.addItem('bbox: ' + self.current_class_id + ' ' + str(bbox))
                    return True

            elif self.isDrawingArrow:
                if not self.drawnArrow:
                    # start drawing
                    start = self.graphicsView.mapToScene(event.pos())
                    print(start)
                    self.arrowStart = start
                    self.arrowEnd = start
                    self.drawnArrow = True
                    return True
                else:
                    # finish drawing
                    end = self.graphicsView.mapToScene(event.pos())
                    self.arrowEnd = end
                    self.drawnArrow = False
                    self.isDrawingArrow = False
                    keypoints = [[round(self.arrowStart.x(), 2), round(self.arrowStart.y(), 2), 1],
                                 [round(self.arrowEnd.x(), 2), round(self.arrowEnd.y(), 2), 1]]
                    self.drawArrow()
                    if self.current_class_id not in self.annotated_keypoints[self.current_file]:
                        self.annotated_keypoints[self.current_file][self.current_class_id] = []
                    self.annotated_keypoints[self.current_file][self.current_class_id].append(keypoints)
                    self.bbox_tbrowser.addItem('kpt: ' + self.current_class_id + ' ' + str(keypoints))
                    return True

        if event.type() == QtCore.QEvent.Wheel and source is self.graphicsView.viewport():
            if self.ctrl_pressed:
                delta = event.angleDelta().y()
                if delta > 0:
                    self.scale_factor *= 1.2
                elif delta < 0:
                    self.scale_factor *= 1 / 1.2
                self.graphicsView.setTransform(QtGui.QTransform().scale(self.scale_factor, self.scale_factor))
                return True

        return super(Ui_Dialog, self).eventFilter(source, event)

    def drawBoundingBox(self):
        # create a QGraphicsRectItem to represent the bounding box
        items = self.scene.items()
        # Iterate through the list to find the item you're looking for
        for item in items:
            if isinstance(item, QtWidgets.QGraphicsRectItem) and item.data(0) == 'preview_box':
                self.scene.removeItem(item)
        rect = QtCore.QRectF(self.startPos, self.endPos)
        item = QtWidgets.QGraphicsRectItem(rect)
        # Grabbing the colors from indices
        R, G, B = [int(i * 255) for i in _COLORS[int(self.current_class_id)]]
        item.setPen(QtGui.QPen(QtGui.QColor(R, G, B)))
        item.setBrush(QtGui.QBrush(QtGui.QColor(R, G, B, 50)))
        self.scene.addItem(item)
        self.startPos = None
        self.endPos = None
        self.drawnBox = False

    def drawArrow(self):
        # create a QGraphicsLineItem to represent the arrow
        items = self.scene.items()
        # Iterate through the list to find the item you're looking for
        for item in items:
            if isinstance(item, QtWidgets.QGraphicsPathItem) and item.data(0) == 'preview_arrow':
                self.scene.removeItem(item)
        arrow = QtGui.QPainterPath()
        arrow.moveTo(self.arrowStart)
        arrow.lineTo(self.arrowEnd)
        arrow_head_len = 20
        arrow_head_angle = 45
        angle = math.atan2(self.arrowEnd.y() - self.arrowStart.y(), self.arrowEnd.x() - self.arrowStart.x())
        arrow_p1 = QtCore.QPointF(
            self.arrowEnd.x() + arrow_head_len * math.cos(angle - math.pi + math.radians(arrow_head_angle)),
            self.arrowEnd.y() + arrow_head_len * math.sin(angle - math.pi + math.radians(arrow_head_angle)))
        arrow_p2 = QtCore.QPointF(
            self.arrowEnd.x() + arrow_head_len * math.cos(angle - math.pi - math.radians(arrow_head_angle)),
            self.arrowEnd.y() + arrow_head_len * math.sin(angle - math.pi - math.radians(arrow_head_angle)))
        arrow.lineTo(arrow_p1)
        arrow.moveTo(self.arrowEnd)
        arrow.lineTo(arrow_p2)
        item = QtWidgets.QGraphicsPathItem(arrow)
        # Grabbing the colors from indices
        R, G, B = [int(i * 255) for i in _COLORS[int(self.current_class_id)]]
        item.setPen(QtGui.QPen(QtGui.QColor(R, G, B), 3))
        self.scene.addItem(item)
        self.arrowStart = None
        self.arrowEnd = None
        self.drawnArrow = False

    def drawBoundingBoxPreview(self):
        items = self.scene.items()

        # Iterate through the list to find the item you're looking for
        for item in items:
            if isinstance(item, QtWidgets.QGraphicsRectItem) and item.data(0) == 'preview_box':
                self.scene.removeItem(item)
        # create a QGraphicsRectItem to represent the bounding box
        rect = QtCore.QRectF(self.startPos, self.endPos)
        item = QtWidgets.QGraphicsRectItem(rect)
        R, G, B = [int(i * 255) for i in
                   _COLORS[int(self.current_class_id)]]  # convert values to integers in range [0, 255]
        item.setPen(QtGui.QPen(QtGui.QColor(R, G, B)))
        item.setBrush(QtGui.QBrush(QtGui.QColor(R, G, B, 50)))
        item.setData(0, 'preview_box')
        self.scene.addItem(item)

    def drawArrowPreview(self):
        # create a QGraphicsLineItem to represent the arrow
        items = self.scene.items()
        # Iterate through the list to find the item you're looking for
        for item in items:
            if isinstance(item, QtWidgets.QGraphicsPathItem) and item.data(0) == 'preview_arrow':
                self.scene.removeItem(item)
        arrow = QtGui.QPainterPath()
        arrow.moveTo(self.arrowStart)
        arrow.lineTo(self.arrowEnd)
        arrow_head_len = 20
        arrow_head_angle = 45
        angle = math.atan2(self.arrowEnd.y() - self.arrowStart.y(), self.arrowEnd.x() - self.arrowStart.x())
        arrow_p1 = QtCore.QPointF(
            self.arrowEnd.x() + arrow_head_len * math.cos(angle - math.pi + math.radians(arrow_head_angle)),
            self.arrowEnd.y() + arrow_head_len * math.sin(angle - math.pi + math.radians(arrow_head_angle)))
        arrow_p2 = QtCore.QPointF(
            self.arrowEnd.x() + arrow_head_len * math.cos(angle - math.pi - math.radians(arrow_head_angle)),
            self.arrowEnd.y() + arrow_head_len * math.sin(angle - math.pi - math.radians(arrow_head_angle)))
        arrow.lineTo(arrow_p1)
        arrow.moveTo(self.arrowEnd)
        arrow.lineTo(arrow_p2)
        item = QtWidgets.QGraphicsPathItem(arrow)
        # Grabbing the colors from indices
        R, G, B = [int(i * 255) for i in _COLORS[int(self.current_class_id)]]
        item.setPen(QtGui.QPen(QtGui.QColor(R, G, B), 3))
        item.setData(0, 'preview_arrow')
        self.scene.addItem(item)

    def augment(self):
        selected_format = self.output_format_combobox.currentText()
        if selected_format != 'KeyPoints RCNN (.json)':
            prob = 0.02
            brightness_range = [-100, 100]
            # set the input and output folder paths
            self.annotated_bboxes_noaug = copy.deepcopy(self.annotated_bboxes)
            input_folder = "./Images"
            output_folder = "./AugmentedImages"

            # loop over all the files in the input folder
            for filename in os.listdir(input_folder):
                # check if the file is an image
                if filename.endswith(".jpg"):
                    # open the image
                    image_path = os.path.join(input_folder, filename)
                    image = Image.open(image_path)
                    print(image.size)

                    # Horizontal Flip
                    if self.hflip_checkbox.isChecked():
                        hflipped_image = image.transpose(Image.FLIP_LEFT_RIGHT)
                        output_filename = os.path.splitext(filename)[0] + '_hflipped.jpg'
                        output_path = os.path.join(output_folder, output_filename)
                        hflipped_image.save(output_path)

                    # Vertical flip
                    if self.vflip_checkbox.isChecked():
                        vflipped_image = image.transpose(Image.FLIP_TOP_BOTTOM)
                        output_filename = os.path.splitext(filename)[0] + '_vflipped.jpg'
                        output_path = os.path.join(output_folder, output_filename)
                        vflipped_image.save(output_path)

                    if self.noises_checkbox.isChecked():
                        # add noise to the image

                        image = cv2.imread(os.path.join("./Images", filename))

                        # Generate mask of pixels to set to white
                        mask = np.random.rand(*image.shape[:2]) < prob

                        # Set pixels to white
                        image[mask, :] = [255, 255, 255]

                        # Save noisy image
                        cv2.imwrite(os.path.join("./AugmentedImages", os.path.splitext(filename)[0]) + '_noises.jpg', image)


                    # randomly adjust the brightness
                    if self.brightness_checkbox.isChecked():
                        image_path = os.path.join(input_folder, filename)
                        image = Image.open(image_path)
                        brightness = random.randint(brightness_range[0], brightness_range[1])
                        adjusted_image = Image.eval(image, lambda x: x + brightness)

                        # save the adjusted image
                        output_filename = os.path.splitext(filename)[0] + "_brchgd" + ".jpg"
                        output_path = os.path.join(output_folder, output_filename)
                        adjusted_image.save(output_path)

            if self.hflip_checkbox.isChecked():
                new_dict_data = {}

                for key, value in self.annotated_bboxes_noaug.items():
                    new_key = key.split(".")[0] + "_hflipped.jpg"
                    new_value = {}
                    image_path = os.path.join(output_folder, new_key)
                    image = Image.open(image_path)
                    image_width = image.width
                    for inner_key, inner_value in value.items():
                        new_inner_value = []
                        for bbox in inner_value:
                            x, y, w, h = bbox
                            new_x = image_width - x - w
                            new_inner_value.append((new_x, y, w, h))
                        new_value[inner_key] = new_inner_value
                    new_dict_data[new_key] = new_value
                self.annotated_bboxes.update(new_dict_data)

            if self.vflip_checkbox.isChecked():
                new_dict_data = {}
                for key, value in self.annotated_bboxes_noaug.items():
                    new_key = key.split(".")[0] + "_vflipped.jpg"
                    new_value = {}
                    image_path = os.path.join(output_folder, new_key)
                    image = Image.open(image_path)
                    image_height = image.height
                    for inner_key, inner_value in value.items():
                        new_inner_value = []
                        for bbox in inner_value:
                            x, y, w, h = bbox
                            new_y = image_height - y - h
                            new_inner_value.append((x, new_y, w, h))
                        new_value[inner_key] = new_inner_value
                    new_dict_data[new_key] = new_value
                self.annotated_bboxes.update(new_dict_data)

            if self.noises_checkbox.isChecked():
                # make a copy of the original dictionary
                new_dict_data = copy.deepcopy(self.annotated_bboxes)

                for key, value in self.annotated_bboxes_noaug.items():
                    # check if the key ends with ".jpg"
                    if key.endswith(".jpg"):
                        # get the new key name with "_noises.jpg" appended to it
                        new_key = key.split(".jpg")[0] + "_noises.jpg"
                        # set the value of the new key to be the same as the original key
                        new_dict_data[new_key] = self.annotated_bboxes[key]

                # concatenate the new dictionary with the original one
                self.annotated_bboxes.update(new_dict_data)

            if self.brightness_checkbox.isChecked():
                # make a copy of the original dictionary
                new_dict_data = copy.deepcopy(self.annotated_bboxes)

                for key, value in self.annotated_bboxes_noaug.items():
                    # check if the key ends with ".jpg"
                    if key.endswith(".jpg"):
                        # get the new key name with "_noises.jpg" appended to it
                        new_key = key.split(".jpg")[0] + "_brchgd.jpg"
                        # set the value of the new key to be the same as the original key
                        new_dict_data[new_key] = self.annotated_bboxes[key]

                # concatenate the new dictionary with the original one
                self.annotated_bboxes.update(new_dict_data)

                for file_name in os.listdir("./AugmentedImages"):
                    if file_name.endswith(".jpg"):
                        shutil.copy(os.path.join("./AugmentedImages", file_name), os.path.join("./Dataset", file_name))
                        self.touch_image(file_name)

        else:
            print('ball so hard')


    def generate_dataset(self):
        folder_path = "./Dataset"

        jpg_count = 0
        for filename in os.listdir(folder_path):
            if filename.endswith(".jpg"):
                jpg_count += 1

        self.total_imgs_label.setText(str(jpg_count))
        if self.tvt_slider.value() != 0:
            self.tvt_split_ratio = self.tvt_slider.value() / 100
        if self.vt_slider.value() != 0:
            self.vt_split_ratio = self.vt_slider.value() / 100

        num_train_imgs = math.ceil(jpg_count * self.tvt_split_ratio)
        num_valtest_imgs = jpg_count - num_train_imgs
        num_val_imgs = math.ceil(num_valtest_imgs * self.vt_split_ratio)
        num_test_imgs = num_valtest_imgs - num_val_imgs
        self.train_imgs_label.setText(str(num_train_imgs))
        self.val_imgs_label.setText(str(num_val_imgs))
        self.test_imgs_label.setText(str(num_test_imgs))
        self.split_dataset(self.annotated_bboxes, self.annotated_keypoints, self.dataset_metadata,
                      num_train_imgs, num_val_imgs, num_test_imgs)

    def train(self):
        if not os.path.exists("Training/yolov7"):
            print("YOLOv7 folder not found")
            subprocess.run(["git", "clone", "https://github.com/WongKinYiu/yolov7.git", "Training/yolov7"],
                           cwd=os.getcwd(), check=True)
            url = "https://github.com/WongKinYiu/yolov7/releases/download/v0.1/yolov7_training.pt"
            filename = "yolov7_training.pt"

            subprocess.run(["powershell", "-Command", f"Invoke-WebRequest -Uri {url} -OutFile {filename}"])
        self.training_thread = threading.Thread(target=self.run_training)
        self.training_thread.start()

    def run_training(self):
        # Run the training command and capture its output
        batch_size = self.batchsize_combobox.currentText()
        epochs = self.epochs_combobox.currentText()
        # read YAML file
        with open('./Training/yolov7/data/hyp.scratch.p5.yaml', 'r') as f:
            data = yaml.safe_load(f)

        # update lr0 value
        learn_rate = float(self.learnrate_combobox.currentText())
        data['lr0'] = learn_rate

        # write updated YAML file back to disk
        with open('./Training/yolov7/data/hyp.scratch.p5.yaml', 'w') as f:
            yaml.dump(data, f)
        command = f"""
            cd ./Training/yolov7 && python train.py --batch {batch_size} --epochs {epochs} --data ../../Exports/yolov7/CrackersDataset/data.yaml --weights 'yolov7_training.pt' --device 0 --hyp data/hyp.scratch.p5.yaml --cfg cfg/training/yolov7.yaml
        """
        os.system(command)

    def read_log_file(self):
        # Get the latest log file
        try:
            log_file = max(glob.glob('./Training/yolov7/runs/train/*/results.txt'), key=os.path.getctime)
        except ValueError:
            return

        with open(log_file, 'r') as f:
            for line in f:
                line_values = line.strip().split()
                epoch, loss, precision, recall, map50 = [line_values[i] for i in [0, 5, 8, 9, 10]]
                epoch = int(epoch.split('/')[0])
                if epoch > self.last_epoch_processed:
                    self.last_epoch_processed = epoch
                    print(epoch, loss, precision, recall, map50)
                    epoch = int(epoch)

                    # Update the line series with the new data point
                    self.loss_series.append(epoch, float(loss))
                    self.precision_series.append(epoch, float(precision))
                    self.recall_series.append(epoch, float(recall))
                    self.map_series.append(epoch, float(map50))

                    # Calculate min and max values for loss
                    loss_min = float('inf')
                    loss_max = float('-inf')

                    for point in self.loss_series.pointsVector():
                        x, y = point.x(), point.y()
                        if y < loss_min:
                            loss_min = y
                        if y > loss_max:
                            loss_max = y

                    # Calculate min and max values for precision
                    precision_min = float('inf')
                    precision_max = float('-inf')

                    for point in self.precision_series.pointsVector():
                        x, y = point.x(), point.y()
                        if y < precision_min:
                            precision_min = y
                        if y > precision_max:
                            precision_max = y

                    # Calculate min and max values for recall
                    recall_min = float('inf')
                    recall_max = float('-inf')

                    for point in self.recall_series.pointsVector():
                        x, y = point.x(), point.y()
                        if y < recall_min:
                            recall_min = y
                        if y > recall_max:
                            recall_max = y

                    # Calculate min and max values for map
                    map_min = float('inf')
                    map_max = float('-inf')

                    for point in self.map_series.pointsVector():
                        x, y = point.x(), point.y()
                        if y < map_min:
                            map_min = y
                        if y > map_max:
                            map_max = y

                    # Update the y-axis range for each graph

                    self.axisY1.setRange(loss_min * 9 / 10, loss_max * 10 / 9)
                    self.axisY2.setRange(precision_min * 9 / 10, precision_max * 10 / 9)
                    self.axisY3.setRange(recall_min * 9 / 10, recall_max * 10 / 9)
                    self.axisY4.setRange(map_min * 9 / 10, map_max * 10 / 9)

                    self.chart1.addAxis(self.axisY1, Qt.AlignLeft)
                    self.chart2.addAxis(self.axisY2, Qt.AlignLeft)
                    self.chart3.addAxis(self.axisY3, Qt.AlignLeft)
                    self.chart4.addAxis(self.axisY4, Qt.AlignLeft)

                    self.loss_series.attachAxis(self.axisX1)
                    self.loss_series.attachAxis(self.axisY1)
                    self.precision_series.attachAxis(self.axisX2)
                    self.precision_series.attachAxis(self.axisY2)
                    self.recall_series.attachAxis(self.axisX3)
                    self.recall_series.attachAxis(self.axisY3)
                    self.map_series.attachAxis(self.axisX4)
                    self.map_series.attachAxis(self.axisY4)
                else:
                    # print("old info")
                    pass

        # Check if the training thread has finished
        if self.training_thread is not None and not self.training_thread.is_alive():
            # Enable the start_training_button
            # self.start_training_button.setEnabled(True)
            print('done')
    def update_graphics_view(self, output):
        print("\n")
        print(output)
        print("\n")


    def split_dataset(self, dict_data, kpt_data, sizes, train_size, val_size, test_size):
        print(dict_data)
        print(kpt_data)
        print(sizes)
        if self.output_format_combobox.currentText() != 'KeyPoints RCNN (.json)':
            if not os.path.exists("./Dataset"):
                os.makedirs("./Dataset")

            folders = ['train', 'test', 'val']
            for folder in folders:
                if not os.path.exists(f"./Dataset/{folder}"):
                    os.makedirs(f"./Dataset/{folder}")

                if not os.path.exists(f"./Dataset/{folder}/images"):
                    os.makedirs(f"./Dataset/{folder}/images")

                if not os.path.exists(f"./Dataset/{folder}/labels"):
                    os.makedirs(f"./Dataset/{folder}/labels")

            normalized_dict = {}
            for filename, annotations in dict_data.items():
                size = sizes[filename]['_size']
                width, height = size[0], size[1]
                normalized_annotations = {}
                for label, bboxes in annotations.items():
                    normalized_bboxes = []
                    for bbox in bboxes:
                        x, y, w, h = bbox
                        w_normalized = w / width
                        h_normalized = h / height
                        x_normalized = x / width + w_normalized / 2
                        y_normalized = y / height + h_normalized / 2
                        normalized_bbox = (x_normalized, y_normalized, w_normalized, h_normalized)
                        normalized_bboxes.append(normalized_bbox)
                    normalized_annotations[label] = normalized_bboxes
                normalized_dict[filename] = normalized_annotations

            print(normalized_dict)

            # Get the list of image names from normalized_dict
            image_names = list(normalized_dict.keys())

            # Split the image names into train, val, and test sets
            train_images, val_test_images = train_test_split(image_names, train_size=train_size, test_size=val_size + test_size)
            val_images, test_images = train_test_split(val_test_images, train_size=val_size, test_size=test_size)

            # Create the train_normalized_dict, val_normalized_dict, and test_normalized_dict
            train_normalized_dict = {img_name: normalized_dict[img_name] for img_name in train_images}
            val_normalized_dict = {img_name: normalized_dict[img_name] for img_name in val_images}
            test_normalized_dict = {img_name: normalized_dict[img_name] for img_name in test_images}

            print(train_normalized_dict)
            print(val_normalized_dict)
            print(test_normalized_dict)

            for img_name, bboxes in train_normalized_dict.items():
                if not os.path.exists(os.path.join("./Dataset", img_name)):
                    print("Data not found")
                else:
                    shutil.copy(os.path.join("./Dataset", img_name), os.path.join("./Dataset/train/images", img_name))
                with open(os.path.join("./Dataset/train/labels", f"{img_name.split('.')[0]}.txt"), "w") as f:
                    for label, boxes in bboxes.items():
                        for box in boxes:
                            x, y, w, h = box
                            f.write(f"{label} {x} {y} {w} {h}\n")

            for img_name, bboxes in val_normalized_dict.items():
                if not os.path.exists(os.path.join("./Dataset", img_name)):
                    print("Data not found")
                else:
                    shutil.copy(os.path.join("./Dataset", img_name), os.path.join("./Dataset/val/images", img_name))
                with open(os.path.join("./Dataset/val/labels", f"{img_name.split('.')[0]}.txt"), "w") as f:
                    for label, boxes in bboxes.items():
                        for box in boxes:
                            x, y, w, h = box
                            f.write(f"{label} {x} {y} {w} {h}\n")

            for img_name, bboxes in test_normalized_dict.items():
                if not os.path.exists(os.path.join("./Dataset", img_name)):
                    print("Data not found")
                else:
                    shutil.copy(os.path.join("./Dataset", img_name), os.path.join("./Dataset/test/images", img_name))
                with open(os.path.join("./Dataset/test/labels", f"{img_name.split('.')[0]}.txt"), "w") as f:
                    for label, boxes in bboxes.items():
                        for box in boxes:
                            x, y, w, h = box
                            f.write(f"{label} {x} {y} {w} {h}\n")
        else:
            val_size = 0
            if not os.path.exists("./Dataset"):
                os.makedirs("./Dataset")

            folders = ['train', 'test']
            for folder in folders:
                if not os.path.exists(f"./Dataset/{folder}"):
                    os.makedirs(f"./Dataset/{folder}")

                if not os.path.exists(f"./Dataset/{folder}/images"):
                    os.makedirs(f"./Dataset/{folder}/images")

                if not os.path.exists(f"./Dataset/{folder}/annotations"):
                    os.makedirs(f"./Dataset/{folder}/annotations")

            normalized_dict = {}
            for filename, annotations in dict_data.items():
                normalized_annotations = {}
                for label, bboxes in annotations.items():
                    normalized_bboxes = []
                    for bbox in bboxes:
                        x, y, w, h = bbox
                        x1 = x
                        y1 = y
                        x2 = x + w
                        y2 = y + h
                        normalized_bbox = [x1, y1, x2, y2]
                        normalized_bboxes.append(normalized_bbox)
                    normalized_annotations[label] = normalized_bboxes
                normalized_dict[filename] = normalized_annotations

            print(normalized_dict)

            for img_name, bboxes in normalized_dict.items():
                kpts = kpt_data[img_name]
                if not os.path.exists(os.path.join("./Dataset", img_name)):
                    print("Data not found")
                else:
                    shutil.copy(os.path.join("./Dataset", img_name), os.path.join("./Dataset/train/images", img_name))
                # dictionary to store bounding boxes
                data = {"bboxes": [], "keypoints": []}

                for label, boxes in bboxes.items():
                    for box in boxes:
                        x, y, w, h = box
                        data["bboxes"].append([x, y, w, h])

                for label, kpts in kpts.items():
                    for kpt in kpts:
                        data["keypoints"].append(kpt)

                with open(os.path.join("./Dataset/train/annotations", f"{img_name.split('.')[0]}.json"), "w") as f:
                    json.dump(data, f)

                # set the percentage of images to move to test set
                percentage = (1 - self.tvt_split_ratio) * self.vt_split_ratio * 100

                # get the list of all image files in the train/images directory
                image_files = [f for f in os.listdir("Dataset/train/images") if f.endswith(".jpg")]

                # randomly select a percentage of the image files
                num_images = int(len(image_files) * percentage / 100)
                test_images = random.sample(image_files, num_images)

                # move the selected images and corresponding annotations to the test directory
                os.makedirs("Dataset/test/images", exist_ok=True)
                os.makedirs("Dataset/test/annotations", exist_ok=True)

                for image in test_images:
                    # move the image file
                    shutil.move(os.path.join("Dataset/train/images", image), os.path.join("Dataset/test/images", image))

                    # move the corresponding annotation file
                    basename = os.path.splitext(image)[0]
                    annotation_file = f"{basename}.json"
                    if os.path.isfile(os.path.join("Dataset/train/annotations", annotation_file)):
                        shutil.move(os.path.join("Dataset/train/annotations", annotation_file),
                                    os.path.join("Dataset/test/annotations", annotation_file))


def find_newest_results_folder():
    results_folders = glob.glob('./Training/yolov7/runs/train/exp*')
    newest_folder = max(results_folders, key=os.path.getctime)
    return newest_folder


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    Dialog = QtWidgets.QDialog()
    ui = Ui_Dialog()
    ui.show()
    app.exec_()
