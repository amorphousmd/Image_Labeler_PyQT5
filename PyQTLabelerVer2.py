# -*- coding: utf-8 -*-

#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


import os
import numpy as np
import re
import json
import random
import cv2
import copy
import math
import glob
import shutil
import subprocess
import threading
from PIL import Image
from sklearn.model_selection import train_test_split

from PyQt5 import QtCore, QtGui, QtWidgets, uic
from PyQt5.QtGui import QPixmap, QPainter
from PyQt5.QtCore import Qt, QRectF, QTimer
from PyQt5.QtWidgets import QGraphicsScene, QFileDialog, QVBoxLayout
from PyQt5.QtChart import QLineSeries, QValueAxis, QChart, QChartView

# YOLOv5 bounding boxes colors
_COLORS = np.array(
    [
        0.000, 0.447, 0.741,
        0.850, 0.325, 0.098,
        0.929, 0.694, 0.125,
        0.494, 0.184, 0.556,
        0.466, 0.674, 0.188,
        0.301, 0.745, 0.933,
        0.635, 0.078, 0.184,
        0.300, 0.300, 0.300,
        0.600, 0.600, 0.600,
        1.000, 0.000, 0.000,
        1.000, 0.500, 0.000,
        0.749, 0.749, 0.000,
        0.000, 1.000, 0.000,
        0.000, 0.000, 1.000,
        0.667, 0.000, 1.000,
        0.333, 0.333, 0.000,
        0.333, 0.667, 0.000,
        0.333, 1.000, 0.000,
        0.667, 0.333, 0.000,
        0.667, 0.667, 0.000,
        0.667, 1.000, 0.000,
        1.000, 0.333, 0.000,
        1.000, 0.667, 0.000,
        1.000, 1.000, 0.000,
        0.000, 0.333, 0.500,
        0.000, 0.667, 0.500,
        0.000, 1.000, 0.500,
        0.333, 0.000, 0.500,
        0.333, 0.333, 0.500,
        0.333, 0.667, 0.500,
        0.333, 1.000, 0.500,
        0.667, 0.000, 0.500,
        0.667, 0.333, 0.500,
        0.667, 0.667, 0.500,
        0.667, 1.000, 0.500,
        1.000, 0.000, 0.500,
        1.000, 0.333, 0.500,
        1.000, 0.667, 0.500,
        1.000, 1.000, 0.500,
        0.000, 0.333, 1.000,
        0.000, 0.667, 1.000,
        0.000, 1.000, 1.000,
        0.333, 0.000, 1.000,
        0.333, 0.333, 1.000,
        0.333, 0.667, 1.000,
        0.333, 1.000, 1.000,
        0.667, 0.000, 1.000,
        0.667, 0.333, 1.000,
        0.667, 0.667, 1.000,
        0.667, 1.000, 1.000,
        1.000, 0.000, 1.000,
        1.000, 0.333, 1.000,
        1.000, 0.667, 1.000,
        0.333, 0.000, 0.000,
        0.500, 0.000, 0.000,
        0.667, 0.000, 0.000,
        0.833, 0.000, 0.000,
        1.000, 0.000, 0.000,
        0.000, 0.167, 0.000,
        0.000, 0.333, 0.000,
        0.000, 0.500, 0.000,
        0.000, 0.667, 0.000,
        0.000, 0.833, 0.000,
        0.000, 1.000, 0.000,
        0.000, 0.000, 0.167,
        0.000, 0.000, 0.333,
        0.000, 0.000, 0.500,
        0.000, 0.000, 0.667,
        0.000, 0.000, 0.833,
        0.000, 0.000, 1.000,
        0.000, 0.000, 0.000,
        0.143, 0.143, 0.143,
        0.286, 0.286, 0.286,
        0.429, 0.429, 0.429,
        0.571, 0.571, 0.571,
        0.714, 0.714, 0.714,
        0.857, 0.857, 0.857,
        0.000, 0.447, 0.741,
        0.314, 0.717, 0.741,
        0.50, 0.5, 0
    ]
).astype(np.float32).reshape(-1, 3)


class Ui_Dialog(QtWidgets.QDialog):
    def __init__(self):
        super().__init__()
        uic.loadUi('GUIDesign.ui', self)
        self.scene = QGraphicsScene()
        self.graphicsView.setScene(self.scene)
        self.graphicsView.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.graphicsView.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.graphicsView.setRenderHint(QtGui.QPainter.Antialiasing)
        self.graphicsView.setRenderHint(QtGui.QPainter.SmoothPixmapTransform)
        self.graphicsView.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)
        self.comboBox.setEditable(True)
        self.comboBox.lineEdit().setAlignment(QtCore.Qt.AlignCenter)
        self.comboBox.addItems('Class 0, Class 1, Class 2'.split(","))
        line_edit = self.comboBox.lineEdit()
        line_edit.setAlignment(Qt.AlignCenter)
        line_edit.setReadOnly(True)
        font = QtGui.QFont()
        font.setPointSize(8)  # set the font size to 12 points
        self.bbox_tbrowser.setFont(font)
        self.output_format_combobox.addItem("YOLOv7 Pytorch (.txt)")
        self.output_format_combobox.addItem("YOLOv5 Pytorch (.txt)")
        self.output_format_combobox.addItem("COCO (.json)")
        self.output_format_combobox.addItem("Tensorflow Detection (.csv)")
        self.model_combobox.addItem("YOLOv7")
        self.model_combobox.addItem("YOLOv7-tiny")
        self.epochs_combobox.addItem("25")
        self.epochs_combobox.addItem("50")
        self.epochs_combobox.addItem("100")
        self.epochs_combobox.addItem("200")
        self.batchsize_combobox.addItem("4")
        self.batchsize_combobox.addItem("8")
        self.batchsize_combobox.addItem("16")
        self.batchsize_combobox.addItem("32")
        self.learnrate_combobox.addItem("0.01")
        self.learnrate_combobox.addItem("0.05")
        self.learnrate_combobox.addItem("0.1")
        self.learnrate_combobox.addItem("0.001")
        self.training_thread = None

        # Timer
        self.log_file_timer = QTimer()
        self.log_file_timer.timeout.connect(self.read_log_file)
        self.log_file_timer.start(1000)  # Check the log file every second
        self.last_epoch_processed = -1

        # QChart visualization setup
        # Initialize the main chart
        # Initialize the line series for loss, precision, recall, and map
        self.loss_series = QLineSeries()
        self.precision_series = QLineSeries()
        self.recall_series = QLineSeries()
        self.map_series = QLineSeries()
        # Create chart 1 for loss series
        chart1 = QChart()
        chart1.setTitle("Loss Progress")
        chart1.legend().hide()
        chartview1 = QChartView(chart1, self.tab_2)
        chartview1.setGeometry(QtCore.QRect(340, 120, 430, 335))
        chartview1.setRenderHint(QPainter.Antialiasing)
        chart1.addSeries(self.loss_series)
        axisX1 = QValueAxis()
        axisX1.setLabelFormat("%d")
        axisX1.setTitleText("Epoch")
        axisX1.setTickCount(11)
        axisX1.setRange(0, 50)
        chart1.addAxis(axisX1, Qt.AlignBottom)
        axisY1 = QValueAxis()
        axisY1.setLabelFormat("%.2f")
        axisY1.setTitleText("Loss")
        axisY1.setTickCount(6)
        chart1.addAxis(axisY1, Qt.AlignLeft)
        self.loss_series.attachAxis(axisX1)
        self.loss_series.attachAxis(axisY1)

        # Create chart 2 for precision series
        chart2 = QChart()
        chart2.setTitle("Precision Progress")
        chart2.legend().hide()
        chartview2 = QChartView(chart2, self.tab_2)
        chartview2.setGeometry(QtCore.QRect(770, 120, 431, 335))
        chartview2.setRenderHint(QPainter.Antialiasing)
        chart2.addSeries(self.precision_series)
        axisX2 = QValueAxis()
        axisX2.setLabelFormat("%d")
        axisX2.setTitleText("Epoch")
        axisX2.setTickCount(11)
        axisX2.setRange(0, 50)
        chart2.addAxis(axisX2, Qt.AlignBottom)
        axisY2 = QValueAxis()
        axisY2.setLabelFormat("%.2f")
        axisY2.setTitleText("Precision")
        axisY2.setTickCount(6)
        chart2.addAxis(axisY2, Qt.AlignLeft)
        self.precision_series.attachAxis(axisX2)
        self.precision_series.attachAxis(axisY2)

        # Create chart 3 for recall series
        chart3 = QChart()
        chart3.setTitle("Recall Progress")
        chart3.legend().hide()
        chartview3 = QChartView(chart3, self.tab_2)
        chartview3.setGeometry(QtCore.QRect(340, 480, 430, 311))
        chartview3.setRenderHint(QPainter.Antialiasing)
        chart3.addSeries(self.recall_series)
        axisX3 = QValueAxis()
        axisX3.setLabelFormat("%d")
        axisX3.setTitleText("Epoch")
        axisX3.setTickCount(11)
        axisX3.setRange(0, 50)
        chart3.addAxis(axisX3, Qt.AlignBottom)
        axisY3 = QValueAxis()
        axisY3.setLabelFormat("%.2f")
        axisY3.setTitleText("Recall")
        axisY3.setTickCount(6)
        chart3.addAxis(axisY3, Qt.AlignLeft)
        self.recall_series.attachAxis(axisX3)
        self.recall_series.attachAxis(axisY3)

        # Create chart 4 for map series
        chart4 = QChart()
        chart4.setTitle("mAP Progress")
        chart4.legend().hide()
        chartview4 = QChartView(chart4, self.tab_2)
        chartview4.setGeometry(QtCore.QRect(770, 480, 431, 311))
        chartview4.setRenderHint(QPainter.Antialiasing)
        chart4.addSeries(self.map_series)
        axisX4 = QValueAxis()
        axisX4.setLabelFormat("%d")
        axisX4.setTitleText("Epoch")
        axisX4.setTickCount(11)
        axisX4.setRange(0, 50)
        chart4.addAxis(axisX4, Qt.AlignBottom)
        axisY4 = QValueAxis()
        axisY4.setLabelFormat("%.2f")
        axisY4.setTitleText("mAP")
        axisY4.setTickCount(6)
        axisY4.setRange(0, 0.001)
        chart4.addAxis(axisY4, Qt.AlignLeft)
        self.map_series.attachAxis(axisX4)
        self.map_series.attachAxis(axisY4)

        # Set up general variables that are used for keeping track of annotated images
        self.image_loaded = False
        self.annotated_bboxes = {}
        self.annotated_bboxes_noaug = {}
        self.dataset_metadata = {}
        self.filename = None
        self.current_file = None
        self.current_dir = "./"
        self.current_class_id = '0'
        self.selected_bbox = None
        self.scale_factor = 1.0
        self.tvt_split_ratio = 0.8
        self.vt_split_ratio = 0.5

        # Connections
        self.cd_button.clicked.connect(self.load_image)
        self.comboBox.currentIndexChanged.connect(self.select_class)
        self.bbox_tbrowser.itemClicked.connect(self.item_clicked)
        self.bbox_tbrowser.focusOutEvent = self.bbox_tbrowser_focus_out
        self.finish_button.clicked.connect(self.save_annotations)
        self.load_annotate_button.clicked.connect(self.load_annotations)
        self.prev_button.clicked.connect(self.load_prev)
        self.next_button.clicked.connect(self.load_next)
        self.goto_button.clicked.connect(self.goto_index)
        self.dir_change_button.clicked.connect(self.change_directory)
        self.export_button.clicked.connect(self.export)
        self.tvt_slider.valueChanged.connect(lambda value: self.tvt_label.setText(str(value)))
        self.vt_slider.valueChanged.connect(lambda value: self.vt_label.setText(str(value)))
        self.generate_dataset_button.clicked.connect(self.generate_dataset)
        self.train_button.clicked.connect(self.train)

        QtCore.QMetaObject.connectSlotsByName(Dialog)
        self.graphicsView.viewport().installEventFilter(self)
        self.graphicsView.setMouseTracking(True)  # add this line
        self.graphicsView.viewport().setCursor(QtCore.Qt.ArrowCursor)
        shortcut = QtWidgets.QShortcut(QtGui.QKeySequence(QtCore.Qt.Key_Escape), self)
        shortcut.activated.connect(self.handleEscape)

        # Setup the values for action handling
        self.startPos = None
        self.endPos = None
        self.drawnBox = False
        self.isDrawing = False
        self.dottedLines = []  # initialize a list to keep track of the dotted lines
        self.ctrl_pressed = False
        self.last_mouse_pos = None
        self.graphicsView.viewport().installEventFilter(self)
        self.graphicsView.setMouseTracking(True)
        self.graphicsView.viewport().setCursor(QtCore.Qt.ArrowCursor)
        shortcut = QtWidgets.QShortcut(QtGui.QKeySequence(QtCore.Qt.Key_Escape), self)
        shortcut.activated.connect(self.handleEscape)

    def load_image(self):
        print(self.annotated_bboxes)
        print(self.dataset_metadata)
        for line in self.dottedLines:
            self.graphicsView.scene().removeItem(line)
        self.dottedLines = []
        # Get the path to the image file using a file dialog
        self.filename, _ = QFileDialog.getOpenFileName(directory="C:/Users/LAPTOP/Desktop/Pics",
                                                       filter="Images (*.png *.xpm *.jpg *.bmp);;All Files (*)")
        if not self.filename:
            return
        self.current_file = str(os.path.basename(self.filename))
        self.current_dir = str(os.path.dirname(self.filename))
        if self.current_file not in self.annotated_bboxes:
            self.annotated_bboxes[self.current_file] = {}
        if self.current_file not in self.dataset_metadata:
            self.dataset_metadata[self.current_file] = {}

        self.image_label.setText(self.current_file)
        self.directory_tbrowser.setText(self.current_dir)
        # Load the image file as a pixmap
        self.graphicsView.scene().clear()
        pixmap = QPixmap(self.filename)
        if pixmap.isNull():
            return
        self.dataset_metadata[self.current_file]['_size'] = [pixmap.width(), pixmap.height()]
        # Set the pixmap as the background for the QGraphicsView widget
        self.scene.clear()
        self.scene.addPixmap(pixmap)
        self.graphicsView.setSceneRect(QRectF(pixmap.rect()))
        self.graphicsView.fitInView(QRectF(pixmap.rect()), Qt.KeepAspectRatio)
        self.redrawBoundingBox(self.current_file)
        self.rewrite_bbox_list(self.current_file)
        self.image_loaded = True

    def load_image_nopath(self, name):
        for line in self.dottedLines:
            self.graphicsView.scene().removeItem(line)
        self.dottedLines = []
        # Get the path to the image file using a file dialog
        self.filename = self.current_dir + '/' + name
        if not self.filename:
            return
        self.current_file = str(os.path.basename(self.filename))
        self.current_dir = str(os.path.dirname(self.filename))
        if self.current_file not in self.annotated_bboxes:
            self.annotated_bboxes[self.current_file] = {}
        if self.current_file not in self.dataset_metadata:
            self.dataset_metadata[self.current_file] = {}

        self.image_label.setText(self.current_file)
        self.directory_tbrowser.setText(self.current_dir)
        # Load the image file as a pixmap
        self.graphicsView.scene().clear()
        pixmap = QPixmap(self.filename)
        if pixmap.isNull():
            return
        self.dataset_metadata[self.current_file]['_size'] = [pixmap.width(), pixmap.height()]
        # Set the pixmap as the background for the QGraphicsView widget
        self.scene.clear()
        self.scene.addPixmap(pixmap)
        self.graphicsView.setSceneRect(QRectF(pixmap.rect()))
        self.graphicsView.fitInView(QRectF(pixmap.rect()), Qt.KeepAspectRatio)
        self.redrawBoundingBox(self.current_file)
        self.rewrite_bbox_list(self.current_file)
        self.image_loaded = True

    def touch_image(self, name):
        self.filename = './Dataset/' + name
        if not self.filename:
            return

        pixmap = QPixmap(self.filename)
        if pixmap.isNull():
            return
        if name not in self.dataset_metadata:
            self.dataset_metadata[name] = {}
        self.dataset_metadata[name]['_size'] = [pixmap.width(), pixmap.height()]

    def change_directory(self):
        options = QFileDialog.Options()
        options |= QFileDialog.DontUseNativeDialog
        current_dir = os.getcwd()
        folder_path = QFileDialog.getExistingDirectory(self, "Select Folder", current_dir, options=options)
        self.current_dir = folder_path
        files = sorted([f for f in os.listdir(self.current_dir) if f.endswith('.jpg') or f.endswith('.png')])
        self.load_image_nopath(files[0])

    def load_next(self):
        parent_dir = self.current_dir
        file = self.current_file
        if file is None or parent_dir is None:
            return
        files = sorted([f for f in os.listdir(parent_dir) if f.endswith('.jpg') or f.endswith('.png')])
        current_index = files.index(file)
        if current_index == len(files) - 1:
            return None  # reached end of list
        else:
            self.load_image_nopath(files[current_index + 1])
            return files[current_index + 1]

    def load_prev(self):
        parent_dir = self.current_dir
        file = self.current_file
        if file is None or parent_dir is None:
            return
        files = sorted([f for f in os.listdir(parent_dir) if f.endswith('.jpg') or f.endswith('.png')])
        current_index = files.index(file)
        if current_index == 0:
            return None  # reached beginning of list
        else:
            self.load_image_nopath(files[current_index - 1])
            return files[current_index - 1]

    def goto_index(self):
        parent_dir = self.current_dir
        file = self.current_file
        if file is None or parent_dir is None:
            return
        files = sorted([f for f in os.listdir(parent_dir) if f.endswith('.jpg') or f.endswith('.png')])
        index_str = self.index_ledit.text()  # Get the text from the line edit
        try:
            index = int(index_str)  # Convert the text to an integer
        except ValueError:
            return  # If the text cannot be converted to an integer, do nothing
        if index < 0:
            index = 0  # If the index is negative, set it to 0
        elif index > len(files) - 1:
            index = len(files) - 1  # If the index is greater than the maximum index, set it to the maximum index
        self.load_image_nopath(files[index])


    def select_class(self, i):
        self.current_class_id = str(i)
        print("Current class:", i)

    def redrawBoundingBox(self, current_file):
        # iterate over each image file in the dictionary
        try:
            for key, value in self.annotated_bboxes[current_file].items():
                for bbox in value:
                    x, y, w, h = bbox
                    rect = QtCore.QRectF(x, y, w, h)
                    item = QtWidgets.QGraphicsRectItem(rect)
                    R, G, B = [int(i * 255) for i in _COLORS[int(key)]]
                    item.setPen(QtGui.QPen(QtGui.QColor(R, G, B)))
                    item.setBrush(QtGui.QBrush(QtGui.QColor(R, G, B, 50)))
                    self.scene.addItem(item)
        except KeyError:
            return

    def redrawBoundingBoxExcept(self, current_file, except_bbox, highlight_class):
        for item in self.scene.items():
            if isinstance(item, QtWidgets.QGraphicsRectItem):
                self.scene.removeItem(item)

        # iterate over each image file in the dictionary
        for key, value in self.annotated_bboxes[current_file].items():
            for bbox in value:
                if bbox == except_bbox:
                    continue
                x, y, w, h = bbox
                rect = QtCore.QRectF(x, y, w, h)
                item = QtWidgets.QGraphicsRectItem(rect)
                R, G, B = [int(i * 255) for i in _COLORS[int(key)]]
                item.setPen(QtGui.QPen(QtGui.QColor(R, G, B)))
                item.setBrush(QtGui.QBrush(QtGui.QColor(R, G, B, 50)))
                self.scene.addItem(item)
        x, y, w, h = except_bbox
        rect = QtCore.QRectF(x, y, w, h)
        item = QtWidgets.QGraphicsRectItem(rect)
        R, G, B = [int(i * 255) for i in _COLORS[int(highlight_class)]]
        item.setPen(QtGui.QPen(QtGui.QColor(R, G, B)))
        item.setBrush(QtGui.QBrush(QtGui.QColor(R, G, B, 150)))
        self.scene.addItem(item)

    def item_clicked(self, item):
        s = item.text()
        tuple_str = re.search(r'\(([\d\.]+),\s*([\d\.]+),\s*([\d\.]+),\s*([\d\.]+)\)', s).group(1, 2, 3, 4)
        bbox = tuple(map(float, tuple_str))
        self.selected_bbox = bbox
        highlight_class = s.split(' ')[0]
        self.redrawBoundingBoxExcept(self.current_file, bbox, highlight_class)

    def bbox_tbrowser_focus_out(self, event):
        for item in self.scene.items():
            if isinstance(item, QtWidgets.QGraphicsRectItem):
                self.scene.removeItem(item)
        self.redrawBoundingBox(self.current_file)

    def rewrite_bbox_list(self, current_file):
        self.bbox_tbrowser.clear()
        for key, value in self.annotated_bboxes[current_file].items():
            for bbox in value:
                self.bbox_tbrowser.addItem(key + ' ' + str(bbox))

    def save_annotations(self):
        filename, _ = QtWidgets.QFileDialog.getSaveFileName(self, "Save File", "./Saves", "JSON Files (*.json)")

        if filename:
            # create dictionary to save
            data = {
                'annotated_bboxes': self.annotated_bboxes,
                'dataset_metadata': self.dataset_metadata
            }
            # write dictionary to file as JSON
            with open(filename, 'w') as f:
                json.dump(data, f)

    def load_annotations(self):
        file_path, _ = QFileDialog.getOpenFileName(None, "Open JSON file", "./Saves", "JSON Files (*.json)")

        if file_path:
            with open(file_path, 'r') as f:
                data = json.load(f)
        try:
            for img, classes in data["annotated_bboxes"].items():
                for cls, bboxes in classes.items():
                    data["annotated_bboxes"][img][cls] = [tuple(bbox) for bbox in bboxes]
        except UnboundLocalError:
            print('No file selected')
            return

        self.annotated_bboxes = data["annotated_bboxes"]
        self.dataset_metadata = data["dataset_metadata"]

        try:
            self.redrawBoundingBox(self.current_file)
        except KeyError:
            pass
        try:
            self.rewrite_bbox_list(self.current_file)
        except KeyError:
            pass

    def handleEscape(self):
        pass  # Without doing this the GUI just closes whenever you press ESC

    def keyPressEvent(self, event):
        if event.key() == QtCore.Qt.Key_B:
            self.isDrawing = True
            event.accept()  # accept the event to stop it from propagating to other widgets
        elif event.key() == QtCore.Qt.Key_Delete:
            for key, value in self.annotated_bboxes[self.current_file].items():
                for bbox in value:
                    if bbox == self.selected_bbox:
                        self.annotated_bboxes[self.current_file][key].remove(bbox)
                        bbox_to_remove = key + ' ' + str(bbox)
                        for i in range(self.bbox_tbrowser.count()):
                            if self.bbox_tbrowser.item(i).text() == bbox_to_remove:
                                self.bbox_tbrowser.takeItem(i)
                                break
            for item in self.scene.items():
                if isinstance(item, QtWidgets.QGraphicsRectItem):
                    self.scene.removeItem(item)
            self.redrawBoundingBox(self.current_file)
            event.accept()  # accept the event to stop it from propagating to other widgets
        elif event.type() == QtCore.QEvent.KeyPress and event.key() == QtCore.Qt.Key_Control:
            self.ctrl_pressed = True
            self.graphicsView.viewport().setCursor(QtCore.Qt.OpenHandCursor)
        else:
            super().keyPressEvent(event)

    def keyReleaseEvent(self, event):
        if event.key() == QtCore.Qt.Key_Control:
            self.ctrl_pressed = False
            self.graphicsView.viewport().setCursor(QtCore.Qt.ArrowCursor)
            event.accept()  # accept the event to stop it from propagating to other widgets

    def eventFilter(self, source, event):
        if event.type() == QtCore.QEvent.MouseMove:
            if not self.image_loaded:
                return super(Ui_Dialog, self).eventFilter(source, event)
            # get the position of the mouse cursor in the scene coordinates
            scenePos = self.graphicsView.mapToScene(event.pos())

            # get the rectangle of the visible area in the view coordinates
            viewRect = self.graphicsView.viewport().rect()

            # clear any existing dotted lines
            try:
                for line in self.dottedLines:
                    self.graphicsView.scene().removeItem(line)
                self.dottedLines = []
            except RuntimeError:
                return super(Ui_Dialog, self).eventFilter(source, event)

            # create a QPen object for the dotted line
            dottedLinePen = QtGui.QPen(QtCore.Qt.DotLine)
            dottedLinePen.setWidth(1)

            # add horizontal and vertical dotted lines intersecting at the cursor position
            horizLine = QtWidgets.QGraphicsLineItem(viewRect.left(), scenePos.y(), viewRect.right(), scenePos.y())
            horizLine.setPen(dottedLinePen)
            self.graphicsView.scene().addItem(horizLine)
            self.dottedLines.append(horizLine)

            vertLine = QtWidgets.QGraphicsLineItem(scenePos.x(), viewRect.top(), scenePos.x(), viewRect.bottom())
            vertLine.setPen(dottedLinePen)
            self.graphicsView.scene().addItem(vertLine)
            self.dottedLines.append(vertLine)

            if self.drawnBox:
                pos = self.graphicsView.mapToScene(event.pos())
                self.endPos = pos
                self.drawBoundingBoxPreview()

            if event.buttons() == QtCore.Qt.LeftButton and self.ctrl_pressed:
                cursor = QtGui.QCursor()
                if self.last_mouse_pos is None:
                    self.last_mouse_pos = cursor.pos()
                    return True
                delta = cursor.pos() - self.last_mouse_pos
                self.last_mouse_pos = cursor.pos()
                dx = delta.x()
                dy = delta.y()
                self.graphicsView.horizontalScrollBar().setValue(self.graphicsView.horizontalScrollBar().value() - dx)
                self.graphicsView.verticalScrollBar().setValue(self.graphicsView.verticalScrollBar().value() - dy)
                return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease and event.button() == QtCore.Qt.LeftButton and \
                event.modifiers() == QtCore.Qt.ControlModifier:
            self.last_mouse_pos = None
            return True

        elif event.type() == QtCore.QEvent.MouseButtonPress and event.button() == QtCore.Qt.LeftButton:
            if self.isDrawing:
                if not self.drawnBox:
                    # start drawing
                    pos = self.graphicsView.mapToScene(event.pos())
                    print(pos)
                    self.startPos = pos
                    self.endPos = pos
                    self.drawnBox = True
                    return True
                else:
                    # finish drawing
                    pos = self.graphicsView.mapToScene(event.pos())
                    print(pos)
                    self.endPos = pos
                    self.drawnBox = False
                    self.isDrawing = False
                    # Get the x and y coordinates of the upper left corner of the bounding box
                    x = min(self.startPos.x(), self.endPos.x())
                    y = min(self.startPos.y(), self.endPos.y())

                    # Get the width and height of the bounding box
                    w = abs(self.startPos.x() - self.endPos.x())
                    h = abs(self.startPos.y() - self.endPos.y())

                    # Create the tuple with (x, y, w, h) coordinates
                    bbox = (round(x, 2), round(y, 2), round(w, 2), round(h, 2))
                    self.drawBoundingBox()
                    if self.current_class_id not in self.annotated_bboxes[self.current_file]:
                        self.annotated_bboxes[self.current_file][self.current_class_id] = []
                    self.annotated_bboxes[self.current_file][self.current_class_id].append(bbox)
                    self.bbox_tbrowser.addItem(self.current_class_id + ' ' + str(bbox))
                    return True

        if event.type() == QtCore.QEvent.Wheel and source is self.graphicsView.viewport():
            if self.ctrl_pressed:
                delta = event.angleDelta().y()
                if delta > 0:
                    self.scale_factor *= 1.2
                elif delta < 0:
                    self.scale_factor *= 1 / 1.2
                self.graphicsView.setTransform(QtGui.QTransform().scale(self.scale_factor, self.scale_factor))
                return True

        return super(Ui_Dialog, self).eventFilter(source, event)

    def drawBoundingBox(self):
        # create a QGraphicsRectItem to represent the bounding box
        items = self.scene.items()
        # Iterate through the list to find the item you're looking for
        for item in items:
            if isinstance(item, QtWidgets.QGraphicsRectItem) and item.data(0) == 'preview_box':
                self.scene.removeItem(item)
        rect = QtCore.QRectF(self.startPos, self.endPos)
        item = QtWidgets.QGraphicsRectItem(rect)
        # Grabbing the colors from indices
        R, G, B = [int(i * 255) for i in _COLORS[int(self.current_class_id)]]
        item.setPen(QtGui.QPen(QtGui.QColor(R, G, B)))
        item.setBrush(QtGui.QBrush(QtGui.QColor(R, G, B, 50)))
        self.scene.addItem(item)
        self.startPos = None
        self.endPos = None
        self.drawnBox = False

    def drawBoundingBoxPreview(self):
        items = self.scene.items()

        # Iterate through the list to find the item you're looking for
        for item in items:
            if isinstance(item, QtWidgets.QGraphicsRectItem) and item.data(0) == 'preview_box':
                self.scene.removeItem(item)
        # create a QGraphicsRectItem to represent the bounding box
        rect = QtCore.QRectF(self.startPos, self.endPos)
        item = QtWidgets.QGraphicsRectItem(rect)
        R, G, B = [int(i * 255) for i in
                   _COLORS[int(self.current_class_id)]]  # convert values to integers in range [0, 255]
        item.setPen(QtGui.QPen(QtGui.QColor(R, G, B)))
        item.setBrush(QtGui.QBrush(QtGui.QColor(R, G, B, 50)))
        item.setData(0, 'preview_box')
        self.scene.addItem(item)

    def export(self):
        prob = 0.02
        brightness_range = [-100, 100]
        # set the input and output folder paths
        self.annotated_bboxes_noaug = copy.deepcopy(self.annotated_bboxes)
        input_folder = "./Images"
        output_folder = "./AugmentedImages"

        # loop over all the files in the input folder
        for filename in os.listdir(input_folder):
            # check if the file is an image
            if filename.endswith(".jpg"):
                # open the image
                image_path = os.path.join(input_folder, filename)
                image = Image.open(image_path)
                print(image.size)

                # Horizontal Flip
                if self.hflip_checkbox.isChecked():
                    hflipped_image = image.transpose(Image.FLIP_LEFT_RIGHT)
                    output_filename = os.path.splitext(filename)[0] + '_hflipped.jpg'
                    output_path = os.path.join(output_folder, output_filename)
                    hflipped_image.save(output_path)

                # Vertical flip
                if self.vflip_checkbox.isChecked():
                    vflipped_image = image.transpose(Image.FLIP_TOP_BOTTOM)
                    output_filename = os.path.splitext(filename)[0] + '_vflipped.jpg'
                    output_path = os.path.join(output_folder, output_filename)
                    vflipped_image.save(output_path)

                if self.noises_checkbox.isChecked():
                    # add noise to the image

                    image = cv2.imread(os.path.join("./Images", filename))

                    # Generate mask of pixels to set to white
                    mask = np.random.rand(*image.shape[:2]) < prob

                    # Set pixels to white
                    image[mask, :] = [255, 255, 255]

                    # Save noisy image
                    cv2.imwrite(os.path.join("./AugmentedImages", os.path.splitext(filename)[0]) + '_noises.jpg', image)


                # randomly adjust the brightness
                if self.brightness_checkbox.isChecked():
                    image_path = os.path.join(input_folder, filename)
                    image = Image.open(image_path)
                    brightness = random.randint(brightness_range[0], brightness_range[1])
                    adjusted_image = Image.eval(image, lambda x: x + brightness)

                    # save the adjusted image
                    output_filename = os.path.splitext(filename)[0] + "_brchgd" + ".jpg"
                    output_path = os.path.join(output_folder, output_filename)
                    adjusted_image.save(output_path)

        if self.hflip_checkbox.isChecked():
            new_dict_data = {}

            for key, value in self.annotated_bboxes_noaug.items():
                new_key = key.split(".")[0] + "_hflipped.jpg"
                new_value = {}
                image_path = os.path.join(output_folder, new_key)
                image = Image.open(image_path)
                image_width = image.width
                for inner_key, inner_value in value.items():
                    new_inner_value = []
                    for bbox in inner_value:
                        x, y, w, h = bbox
                        new_x = image_width - x - w
                        new_inner_value.append((new_x, y, w, h))
                    new_value[inner_key] = new_inner_value
                new_dict_data[new_key] = new_value
            self.annotated_bboxes.update(new_dict_data)

        if self.vflip_checkbox.isChecked():
            new_dict_data = {}
            for key, value in self.annotated_bboxes_noaug.items():
                new_key = key.split(".")[0] + "_vflipped.jpg"
                new_value = {}
                image_path = os.path.join(output_folder, new_key)
                image = Image.open(image_path)
                image_height = image.height
                for inner_key, inner_value in value.items():
                    new_inner_value = []
                    for bbox in inner_value:
                        x, y, w, h = bbox
                        new_y = image_height - y - h
                        new_inner_value.append((x, new_y, w, h))
                    new_value[inner_key] = new_inner_value
                new_dict_data[new_key] = new_value
            self.annotated_bboxes.update(new_dict_data)

        if self.noises_checkbox.isChecked():
            # make a copy of the original dictionary
            new_dict_data = copy.deepcopy(self.annotated_bboxes)

            for key, value in self.annotated_bboxes_noaug.items():
                # check if the key ends with ".jpg"
                if key.endswith(".jpg"):
                    # get the new key name with "_noises.jpg" appended to it
                    new_key = key.split(".jpg")[0] + "_noises.jpg"
                    # set the value of the new key to be the same as the original key
                    new_dict_data[new_key] = self.annotated_bboxes[key]

            # concatenate the new dictionary with the original one
            self.annotated_bboxes.update(new_dict_data)

        if self.brightness_checkbox.isChecked():
            # make a copy of the original dictionary
            new_dict_data = copy.deepcopy(self.annotated_bboxes)

            for key, value in self.annotated_bboxes_noaug.items():
                # check if the key ends with ".jpg"
                if key.endswith(".jpg"):
                    # get the new key name with "_noises.jpg" appended to it
                    new_key = key.split(".jpg")[0] + "_brchgd.jpg"
                    # set the value of the new key to be the same as the original key
                    new_dict_data[new_key] = self.annotated_bboxes[key]

            # concatenate the new dictionary with the original one
            self.annotated_bboxes.update(new_dict_data)

            for file_name in os.listdir("./AugmentedImages"):
                if file_name.endswith(".jpg"):
                    shutil.copy(os.path.join("./AugmentedImages", file_name), os.path.join("./Dataset", file_name))
                    self.touch_image(file_name)

    def generate_dataset(self):
        folder_path = "./Dataset"

        jpg_count = 0
        for filename in os.listdir(folder_path):
            if filename.endswith(".jpg"):
                jpg_count += 1

        self.total_imgs_label.setText(str(jpg_count))
        if self.tvt_slider.value() != 0:
            self.tvt_split_ratio = self.tvt_slider.value() / 100
        if self.vt_slider.value() != 0:
            self.vt_split_ratio = self.vt_slider.value() / 100

        num_train_imgs = math.ceil(jpg_count * self.tvt_split_ratio)
        num_valtest_imgs = jpg_count - num_train_imgs
        num_val_imgs = math.ceil(num_valtest_imgs * self.vt_split_ratio)
        num_test_imgs = num_valtest_imgs - num_val_imgs
        self.train_imgs_label.setText(str(num_train_imgs))
        self.val_imgs_label.setText(str(num_val_imgs))
        self.test_imgs_label.setText(str(num_test_imgs))
        split_dataset(self.annotated_bboxes, self.dataset_metadata, num_train_imgs, num_val_imgs, num_test_imgs)

    def train(self):
        if not os.path.exists("Training/yolov7"):
            print("YOLOv7 folder not found")
            subprocess.run(["git", "clone", "https://github.com/WongKinYiu/yolov7.git", "Training/yolov7"],
                           cwd=os.getcwd(), check=True)
            url = "https://github.com/WongKinYiu/yolov7/releases/download/v0.1/yolov7_training.pt"
            filename = "yolov7_training.pt"

            subprocess.run(["powershell", "-Command", f"Invoke-WebRequest -Uri {url} -OutFile {filename}"])
        self.training_thread = threading.Thread(target=self.run_training)
        self.training_thread.start()

    def run_training(self):
        # Run the training command and capture its output
        command = """
                    cd ./Training/yolov7 && python train.py --batch 1 --epochs 50 --data ../../Exports/yolov7/CrackersDataset/data.yaml --weights 'yolov7_training.pt' --device 0 --hyp data/hyp.scratch.p5.yaml --cfg cfg/training/yolov7.yaml
                """
        os.system(command)

    def read_log_file(self):
        # Get the latest log file
        try:
            log_file = max(glob.glob('./Training/yolov7/runs/train/*/results.txt'), key=os.path.getctime)
        except ValueError:
            print("Baby don't hurt me, don't hurt me, no more")
            return

        with open(log_file, 'r') as f:
            for line in f:
                line_values = line.strip().split()
                epoch, loss, precision, recall, map50 = [line_values[i] for i in [0, 5, 8, 9, 10]]
                epoch = int(epoch.split('/')[0])
                if epoch > self.last_epoch_processed:
                    self.last_epoch_processed = epoch
                    print(epoch, loss, precision, recall, map50)
                    epoch = int(epoch)

                    # Update the line series with the new data point
                    self.loss_series.append(epoch, float(loss))
                    self.precision_series.append(epoch, float(precision))
                    self.recall_series.append(epoch, float(recall))
                    self.map_series.append(epoch, float(map50))
                else:
                    # print("old info")
                    pass

        # Check if the training thread has finished
        if self.training_thread is not None and not self.training_thread.is_alive():
            # Enable the start_training_button
            # self.start_training_button.setEnabled(True)
            print('done')
    def update_graphics_view(self, output):
        print("\n")
        print(output)
        print("\n")


def split_dataset(dict_data, sizes, train_size, val_size, test_size):
    print(dict_data)
    print(sizes)
    if not os.path.exists("./Dataset"):
        os.makedirs("./Dataset")

    folders = ['train', 'test', 'val']
    for folder in folders:
        if not os.path.exists(f"./Dataset/{folder}"):
            os.makedirs(f"./Dataset/{folder}")

        if not os.path.exists(f"./Dataset/{folder}/images"):
            os.makedirs(f"./Dataset/{folder}/images")

        if not os.path.exists(f"./Dataset/{folder}/labels"):
            os.makedirs(f"./Dataset/{folder}/labels")

    normalized_dict = {}
    for filename, annotations in dict_data.items():
        size = sizes[filename]['_size']
        width, height = size[0], size[1]
        normalized_annotations = {}
        for label, bboxes in annotations.items():
            normalized_bboxes = []
            for bbox in bboxes:
                x, y, w, h = bbox
                w_normalized = w / width
                h_normalized = h / height
                x_normalized = x / width + w_normalized / 2
                y_normalized = y / height + h_normalized / 2
                normalized_bbox = (x_normalized, y_normalized, w_normalized, h_normalized)
                normalized_bboxes.append(normalized_bbox)
            normalized_annotations[label] = normalized_bboxes
        normalized_dict[filename] = normalized_annotations

    print(normalized_dict)

    # Get the list of image names from normalized_dict
    image_names = list(normalized_dict.keys())

    # Split the image names into train, val, and test sets
    train_images, val_test_images = train_test_split(image_names, train_size=train_size, test_size=val_size + test_size)
    val_images, test_images = train_test_split(val_test_images, train_size=val_size, test_size=test_size)

    # Create the train_normalized_dict, val_normalized_dict, and test_normalized_dict
    train_normalized_dict = {img_name: normalized_dict[img_name] for img_name in train_images}
    val_normalized_dict = {img_name: normalized_dict[img_name] for img_name in val_images}
    test_normalized_dict = {img_name: normalized_dict[img_name] for img_name in test_images}

    print(train_normalized_dict)
    print(val_normalized_dict)
    print(test_normalized_dict)

    for img_name, bboxes in train_normalized_dict.items():
        if not os.path.exists(os.path.join("./Dataset", img_name)):
            print("Data not found")
        else:
            shutil.copy(os.path.join("./Dataset", img_name), os.path.join("./Dataset/train/images", img_name))
        with open(os.path.join("./Dataset/train/labels", f"{img_name.split('.')[0]}.txt"), "w") as f:
            for label, boxes in bboxes.items():
                for box in boxes:
                    x, y, w, h = box
                    f.write(f"{label} {x} {y} {w} {h}\n")

    for img_name, bboxes in val_normalized_dict.items():
        if not os.path.exists(os.path.join("./Dataset", img_name)):
            print("Data not found")
        else:
            shutil.copy(os.path.join("./Dataset", img_name), os.path.join("./Dataset/val/images", img_name))
        with open(os.path.join("./Dataset/val/labels", f"{img_name.split('.')[0]}.txt"), "w") as f:
            for label, boxes in bboxes.items():
                for box in boxes:
                    x, y, w, h = box
                    f.write(f"{label} {x} {y} {w} {h}\n")

    for img_name, bboxes in test_normalized_dict.items():
        if not os.path.exists(os.path.join("./Dataset", img_name)):
            print("Data not found")
        else:
            shutil.copy(os.path.join("./Dataset", img_name), os.path.join("./Dataset/test/images", img_name))
        with open(os.path.join("./Dataset/test/labels", f"{img_name.split('.')[0]}.txt"), "w") as f:
            for label, boxes in bboxes.items():
                for box in boxes:
                    x, y, w, h = box
                    f.write(f"{label} {x} {y} {w} {h}\n")

def find_newest_results_folder():
    results_folders = glob.glob('./Training/yolov7/runs/train/exp*')
    newest_folder = max(results_folders, key=os.path.getctime)
    return newest_folder



if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    Dialog = QtWidgets.QDialog()
    ui = Ui_Dialog()
    ui.show()
    app.exec_()
